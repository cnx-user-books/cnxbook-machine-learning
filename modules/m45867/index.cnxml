<document xmlns="http://cnx.rice.edu/cnxml" xmlns:m="http://www.w3.org/1998/Math/MathML">
  <title>Machine Learning Lecture 3 Course Notes</title>
<metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m45867</md:content-id>
  <md:title>Machine Learning Lecture 3 Course Notes</md:title>
  <md:abstract/>
  <md:uuid>ad17b113-0217-4fc2-846e-10afa5b4c9d5</md:uuid>
</metadata>

<content>
     <section id="cid1">
      <title>Support Vector Machines</title>
      <para id="id62557">This set of notes presents the Support Vector Machine (SVM) learning algorithm.
SVMs are among the best (and many believe are indeed the best) “off-the-shelf”
supervised learning algorithm. To tell the SVM story, we'll need to first talk about margins and the idea of
separating data with a large “gap.” Next, we'll talk about the optimal margin
classifier, which will lead us into a digression on Lagrange duality. We'll also see
kernels, which give a way to apply SVMs efficiently in very high
dimensional (such as infinite-dimensional) feature spaces, and finally, we'll
close off the story with the SMO algorithm, which gives an efficient implementation
of SVMs.</para>
    </section>
    <section id="cid2">
      <title>Margins: Intuition</title>
      <para id="id62577">We'll start our story on SVMs by talking about margins. This section will give the
intuitions about margins and about the “confidence” of our predictions; these ideas
will be made formal in <link target-id="cid4">"Functional and geometric margins"</link>.</para>
      <para id="id62588">Consider logistic regression,
where the probability <m:math overflow="scroll"><m:mrow><m:mi>p</m:mi><m:mo>(</m:mo><m:mi>y</m:mi><m:mo>=</m:mo><m:mn>1</m:mn><m:mo>|</m:mo><m:mi>x</m:mi><m:mo>;</m:mo><m:mi>θ</m:mi><m:mo>)</m:mo></m:mrow></m:math> is modeled by <m:math overflow="scroll"><m:mrow><m:msub><m:mi>h</m:mi><m:mi>θ</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mi>g</m:mi><m:mrow><m:mo>(</m:mo><m:msup><m:mi>θ</m:mi><m:mi>T</m:mi></m:msup><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:math>.
We would then predict “1” on an input <m:math overflow="scroll"><m:mi>x</m:mi></m:math> if and only if <m:math overflow="scroll"><m:mrow><m:msub><m:mi>h</m:mi><m:mi>θ</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow><m:mo>≥</m:mo><m:mn>0</m:mn><m:mo>.</m:mo><m:mn>5</m:mn></m:mrow></m:math>, or equivalently,
if and only if <m:math overflow="scroll"><m:mrow><m:msup><m:mi>θ</m:mi><m:mi>T</m:mi></m:msup><m:mi>x</m:mi><m:mo>≥</m:mo><m:mn>0</m:mn></m:mrow></m:math>. Consider a positive training example (<m:math overflow="scroll"><m:mrow><m:mi>y</m:mi><m:mo>=</m:mo><m:mn>1</m:mn></m:mrow></m:math>). The larger
<m:math overflow="scroll"><m:mrow><m:msup><m:mi>θ</m:mi><m:mi>T</m:mi></m:msup><m:mi>x</m:mi></m:mrow></m:math> is, the larger also is <m:math overflow="scroll"><m:mrow><m:msub><m:mi>h</m:mi><m:mi>θ</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mi>p</m:mi><m:mrow><m:mo>(</m:mo><m:mi>y</m:mi><m:mo>=</m:mo><m:mn>1</m:mn><m:mo>|</m:mo><m:mi>x</m:mi><m:mo>;</m:mo><m:mi>w</m:mi><m:mo>,</m:mo><m:mi>b</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:math>, and thus also the higher our
degree of “confidence” that the label is 1. Thus, informally we can think of our
prediction as being a very confident one that <m:math overflow="scroll"><m:mrow><m:mi>y</m:mi><m:mo>=</m:mo><m:mn>1</m:mn></m:mrow></m:math> if <m:math overflow="scroll"><m:mrow><m:msup><m:mi>θ</m:mi><m:mi>T</m:mi></m:msup><m:mi>x</m:mi><m:mo>≫</m:mo><m:mn>0</m:mn></m:mrow></m:math>. Similarly, we
think of logistic regression as making a very confident prediction of <m:math overflow="scroll"><m:mrow><m:mi>y</m:mi><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow></m:math>, if <m:math overflow="scroll"><m:mrow><m:msup><m:mi>θ</m:mi><m:mi>T</m:mi></m:msup><m:mi>x</m:mi><m:mo>≪</m:mo><m:mn>0</m:mn></m:mrow></m:math>.
Given a training set, again informally it seems that we'd have found a good fit to the
training data if we can find <m:math overflow="scroll"><m:mi>θ</m:mi></m:math>
so that <m:math overflow="scroll"><m:mrow><m:msup><m:mi>θ</m:mi><m:mi>T</m:mi></m:msup><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>≫</m:mo><m:mn>0</m:mn></m:mrow></m:math> whenever <m:math overflow="scroll"><m:mrow><m:msup><m:mi>y</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>=</m:mo><m:mn>1</m:mn></m:mrow></m:math>, and
<m:math overflow="scroll"><m:mrow><m:msup><m:mi>θ</m:mi><m:mi>T</m:mi></m:msup><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>≪</m:mo><m:mn>0</m:mn></m:mrow></m:math> whenever <m:math overflow="scroll"><m:mrow><m:msup><m:mi>y</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow></m:math>, since this would reflect a very confident (and correct)
set of classifications for all the training examples. This seems to be a nice goal to
aim for, and we'll soon formalize this idea using the notion of functional margins.</para>
      <para id="id63173">For a different type of intuition, consider the following figure, in which x's represent
positive training examples, o's denote negative training examples,
a decision boundary
(this is the line given by the equation <m:math overflow="scroll"><m:mrow><m:msup><m:mi>θ</m:mi><m:mi>T</m:mi></m:msup><m:mi>x</m:mi><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow></m:math>, and is also called
the <emphasis effect="bold">separating hyperplane</emphasis>) is also shown, and three points have also been labeled
A, B and C.</para>
      <figure id="uid1"><media id="uid1_media" alt="a data set broken into two types with a line in between them">
          <image mime-type="image/png" src="../../media/geometricMargin1.png" id="uid1_onlineimage" width="348"><!-- NOTE: attribute width changes image size online (pixels). original width is 348. --></image>
          <image mime-type="application/postscript" for="pdf" print-width="3.5in" src="../../media/geometricMargin1.eps" id="uid1_printimage"/>
        </media>
      </figure><para id="id63212">Notice that the point A is very far from the decision boundary. If we are asked to make a prediction
for the value of <m:math overflow="scroll"><m:mi>y</m:mi></m:math> at A, it seems we should be quite confident that <m:math overflow="scroll"><m:mrow><m:mi>y</m:mi><m:mo>=</m:mo><m:mn>1</m:mn></m:mrow></m:math> there.
Conversely, the point C is very close to the decision boundary, and while it's on the
side of the decision boundary on which we would predict <m:math overflow="scroll"><m:mrow><m:mi>y</m:mi><m:mo>=</m:mo><m:mn>1</m:mn></m:mrow></m:math>, it seems likely that just
a small change to the decision boundary could easily have caused our prediction to be <m:math overflow="scroll"><m:mrow><m:mi>y</m:mi><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow></m:math>.
Hence, we're much more confident about our prediction at A than at C. The point B lies
in-between these two cases, and more broadly, we see that if a point is far from the
separating hyperplane, then we may be significantly more confident in our predictions.
Again, informally we think it'd be nice if, given a training set, we manage to find a
decision boundary that allows us to make all correct and confident (meaning far from the
decision boundary) predictions on the training examples. We'll formalize this later using
the notion of geometric margins.</para>
    </section>
    <section id="cid3">
      <title>Notation</title>
      <para id="id63281">To make our discussion of SVMs easier, we'll first need to introduce a new notation
for talking about classification.
We will be considering a linear classifier for a binary
classification problem with labels <m:math overflow="scroll"><m:mi>y</m:mi></m:math> and features <m:math overflow="scroll"><m:mi>x</m:mi></m:math>. From now, we'll
use <m:math overflow="scroll"><m:mrow><m:mi>y</m:mi><m:mo>∈</m:mo><m:mo>{</m:mo><m:mo>-</m:mo><m:mn>1</m:mn><m:mo>,</m:mo><m:mn>1</m:mn><m:mo>}</m:mo></m:mrow></m:math> (instead of <m:math overflow="scroll"><m:mrow><m:mo>{</m:mo><m:mn>0</m:mn><m:mo>,</m:mo><m:mn>1</m:mn><m:mo>}</m:mo></m:mrow></m:math>) to denote the class labels. Also, rather
than parameterizing our linear
classifier with the vector <m:math overflow="scroll"><m:mi>θ</m:mi></m:math>, we will use parameters <m:math overflow="scroll"><m:mrow><m:mi>w</m:mi><m:mo>,</m:mo><m:mi>b</m:mi></m:mrow></m:math>, and write our
classifier as</para>
      <equation id="id63365">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:msub>
              <m:mi>h</m:mi>
              <m:mrow>
                <m:mi>w</m:mi>
                <m:mo>,</m:mo>
                <m:mi>b</m:mi>
              </m:mrow>
            </m:msub>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>x</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:mi>g</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:msup>
                <m:mi>w</m:mi>
                <m:mi>T</m:mi>
              </m:msup>
              <m:mi>x</m:mi>
              <m:mo>+</m:mo>
              <m:mi>b</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id63420">Here, <m:math overflow="scroll"><m:mrow><m:mi>g</m:mi><m:mo>(</m:mo><m:mi>z</m:mi><m:mo>)</m:mo><m:mo>=</m:mo><m:mn>1</m:mn></m:mrow></m:math> if <m:math overflow="scroll"><m:mrow><m:mi>z</m:mi><m:mo>≥</m:mo><m:mn>0</m:mn></m:mrow></m:math>, and <m:math overflow="scroll"><m:mrow><m:mi>g</m:mi><m:mo>(</m:mo><m:mi>z</m:mi><m:mo>)</m:mo><m:mo>=</m:mo><m:mo>-</m:mo><m:mn>1</m:mn></m:mrow></m:math> otherwise.
This “<m:math overflow="scroll"><m:mrow><m:mi>w</m:mi><m:mo>,</m:mo><m:mi>b</m:mi></m:mrow></m:math>” notation allows us to explicitly treat the intercept term <m:math overflow="scroll"><m:mi>b</m:mi></m:math> separately
from the other parameters. (We also drop the convention we had previously of letting <m:math overflow="scroll"><m:mrow><m:msub><m:mi>x</m:mi><m:mn>0</m:mn></m:msub><m:mo>=</m:mo><m:mn>1</m:mn></m:mrow></m:math> be
an extra coordinate in the input feature vector.) Thus, <m:math overflow="scroll"><m:mi>b</m:mi></m:math> takes the role of what was previously
<m:math overflow="scroll"><m:msub><m:mi>θ</m:mi><m:mn>0</m:mn></m:msub></m:math>, and <m:math overflow="scroll"><m:mi>w</m:mi></m:math> takes the role of <m:math overflow="scroll"><m:msup><m:mrow><m:mo>[</m:mo><m:msub><m:mi>θ</m:mi><m:mn>1</m:mn></m:msub><m:mo>...</m:mo><m:msub><m:mi>θ</m:mi><m:mi>n</m:mi></m:msub><m:mo>]</m:mo></m:mrow><m:mi>T</m:mi></m:msup></m:math>.</para>
      <para id="id63585">Note also that, from our definition of <m:math overflow="scroll"><m:mi>g</m:mi></m:math> above, our classifier will directly
predict either 1 or <m:math overflow="scroll"><m:mrow><m:mo>-</m:mo><m:mn>1</m:mn></m:mrow></m:math> (cf. the perceptron algorithm), without first going through
the intermediate step of estimating the probability of <m:math overflow="scroll"><m:mi>y</m:mi></m:math> being 1 (which
was what logistic regression did).</para>
    </section>
    <section id="cid4">
      <title>Functional and geometric margins</title>
      <para id="id63626">Let's formalize the notions of the functional and geometric margins. Given a training example
<m:math overflow="scroll"><m:mrow><m:mo>(</m:mo><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>,</m:mo><m:msup><m:mi>y</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>)</m:mo></m:mrow></m:math>, we define the <emphasis effect="bold">functional margin</emphasis> of <m:math overflow="scroll"><m:mrow><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>,</m:mo><m:mi>b</m:mi><m:mo>)</m:mo></m:mrow></m:math> with respect to the
training example</para>
      <equation id="id63692"><m:math overflow="scroll" mode="display">
          <m:mrow>
              <m:mrow>
                <m:mover accent="true">
                  <m:mi>γ</m:mi>
                  <m:mo>^</m:mo>
                </m:mover>
              </m:mrow>
            <m:msup>
              <m:mrow/>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>i</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
            </m:msup>
            <m:mo>=</m:mo>
            <m:msup>
              <m:mi>y</m:mi>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>i</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
            </m:msup>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:msup>
                <m:mi>w</m:mi>
                <m:mi>T</m:mi>
              </m:msup>
              <m:mi>x</m:mi>
              <m:mo>+</m:mo>
              <m:mi>b</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation><para id="id63756">Note that if <m:math overflow="scroll"><m:mrow><m:msup><m:mi>y</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>=</m:mo><m:mn>1</m:mn></m:mrow></m:math>, then for the functional margin to be large (i.e., for our prediction
to be confident and correct), we need <m:math overflow="scroll"><m:mrow><m:msup><m:mi>w</m:mi><m:mi>T</m:mi></m:msup><m:mi>x</m:mi><m:mo>+</m:mo><m:mi>b</m:mi></m:mrow></m:math> to be a large positive number.
Conversely, if <m:math overflow="scroll"><m:mrow><m:msup><m:mi>y</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>=</m:mo><m:mo>-</m:mo><m:mn>1</m:mn></m:mrow></m:math>, then for the functional margin to be large, we need <m:math overflow="scroll"><m:mrow><m:msup><m:mi>w</m:mi><m:mi>T</m:mi></m:msup><m:mi>x</m:mi><m:mo>+</m:mo><m:mi>b</m:mi></m:mrow></m:math>
to be a large negative number. Moreover, if
<m:math overflow="scroll"><m:mrow><m:msup><m:mi>y</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mrow><m:mo>(</m:mo><m:msup><m:mi>w</m:mi><m:mi>T</m:mi></m:msup><m:mi>x</m:mi><m:mo>+</m:mo><m:mi>b</m:mi><m:mo>)</m:mo></m:mrow><m:mo>&gt;</m:mo><m:mn>0</m:mn></m:mrow></m:math>, then our prediction on this example is correct. (Check this yourself.)
Hence, a large functional margin represents a confident and a correct prediction.</para>
      <para id="id63900">For a linear classifier with the choice of <m:math overflow="scroll"><m:mi>g</m:mi></m:math> given above (taking values in <m:math overflow="scroll"><m:mrow><m:mo>{</m:mo><m:mo>-</m:mo><m:mn>1</m:mn><m:mo>,</m:mo><m:mn>1</m:mn><m:mo>}</m:mo></m:mrow></m:math>),
there's one property of the functional margin that makes it not a very good measure of confidence,
however. Given our choice of <m:math overflow="scroll"><m:mi>g</m:mi></m:math>, we note that if we replace <m:math overflow="scroll"><m:mi>w</m:mi></m:math> with <m:math overflow="scroll"><m:mrow><m:mn>2</m:mn><m:mi>w</m:mi></m:mrow></m:math> and
<m:math overflow="scroll"><m:mi>b</m:mi></m:math> with <m:math overflow="scroll"><m:mrow><m:mn>2</m:mn><m:mi>b</m:mi></m:mrow></m:math>, then since
<m:math overflow="scroll"><m:mrow><m:mi>g</m:mi><m:mrow><m:mo>(</m:mo><m:msup><m:mi>w</m:mi><m:mi>T</m:mi></m:msup><m:mi>x</m:mi><m:mo>+</m:mo><m:mi>b</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mi>g</m:mi><m:mrow><m:mo>(</m:mo><m:mn>2</m:mn><m:msup><m:mi>w</m:mi><m:mi>T</m:mi></m:msup><m:mi>x</m:mi><m:mo>+</m:mo><m:mn>2</m:mn><m:mi>b</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:math>, this would not change <m:math overflow="scroll"><m:mrow><m:msub><m:mi>h</m:mi><m:mrow><m:mi>w</m:mi><m:mo>,</m:mo><m:mi>b</m:mi></m:mrow></m:msub><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:math> at all. I.e., <m:math overflow="scroll"><m:mi>g</m:mi></m:math>, and hence
also <m:math overflow="scroll"><m:mrow><m:msub><m:mi>h</m:mi><m:mrow><m:mi>w</m:mi><m:mo>,</m:mo><m:mi>b</m:mi></m:mrow></m:msub><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:math>, depends
only on the sign, but not on the magnitude, of <m:math overflow="scroll"><m:mrow><m:msup><m:mi>w</m:mi><m:mi>T</m:mi></m:msup><m:mi>x</m:mi><m:mo>+</m:mo><m:mi>b</m:mi></m:mrow></m:math>. However, replacing <m:math overflow="scroll"><m:mrow><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>,</m:mo><m:mi>b</m:mi><m:mo>)</m:mo></m:mrow></m:math> with
<m:math overflow="scroll"><m:mrow><m:mo>(</m:mo><m:mn>2</m:mn><m:mi>w</m:mi><m:mo>,</m:mo><m:mn>2</m:mn><m:mi>b</m:mi><m:mo>)</m:mo></m:mrow></m:math> also results in multiplying our functional margin by a factor of 2. Thus, it seems
that by exploiting our freedom to scale <m:math overflow="scroll"><m:mi>w</m:mi></m:math> and <m:math overflow="scroll"><m:mi>b</m:mi></m:math>, we can make the functional margin arbitrarily
large without really changing anything meaningful. Intuitively, it might therefore make sense
to impose some sort of normalization condition such as that <m:math overflow="scroll"><m:mrow><m:msub><m:mrow><m:mo>|</m:mo><m:mo>|</m:mo><m:mi>w</m:mi><m:mo>|</m:mo><m:mo>|</m:mo></m:mrow><m:mn>2</m:mn></m:msub><m:mo>=</m:mo><m:mn>1</m:mn></m:mrow></m:math>; i.e., we might
replace <m:math overflow="scroll"><m:mrow><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>,</m:mo><m:mi>b</m:mi><m:mo>)</m:mo></m:mrow></m:math> with <m:math overflow="scroll"><m:mrow><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>/</m:mo><m:mo>|</m:mo><m:mo>|</m:mo><m:mi>w</m:mi><m:mo>|</m:mo><m:msub><m:mo>|</m:mo><m:mn>2</m:mn></m:msub><m:mo>,</m:mo><m:mi>b</m:mi><m:mo>/</m:mo><m:mo>|</m:mo><m:mo>|</m:mo><m:mi>w</m:mi><m:mo>|</m:mo><m:msub><m:mo>|</m:mo><m:mn>2</m:mn></m:msub><m:mo>)</m:mo></m:mrow></m:math>, and instead consider the functional margin of
<m:math overflow="scroll"><m:mrow><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>/</m:mo><m:mo>|</m:mo><m:mo>|</m:mo><m:mi>w</m:mi><m:mo>|</m:mo><m:msub><m:mo>|</m:mo><m:mn>2</m:mn></m:msub><m:mo>,</m:mo><m:mi>b</m:mi><m:mo>/</m:mo><m:mo>|</m:mo><m:mo>|</m:mo><m:mi>w</m:mi><m:mo>|</m:mo><m:msub><m:mo>|</m:mo><m:mn>2</m:mn></m:msub><m:mo>)</m:mo></m:mrow></m:math>. We'll come back to this later.</para>
      <para id="id64328">Given a training set <m:math overflow="scroll"><m:mrow><m:mi>S</m:mi><m:mo>=</m:mo><m:mo>{</m:mo><m:mrow><m:mo>(</m:mo><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>,</m:mo><m:msup><m:mi>y</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>)</m:mo></m:mrow><m:mo>;</m:mo><m:mi>i</m:mi><m:mo>=</m:mo><m:mn>1</m:mn><m:mo>,</m:mo><m:mo>...</m:mo><m:mo>,</m:mo><m:mi>m</m:mi><m:mo>}</m:mo></m:mrow></m:math>, we also define the function
margin of <m:math overflow="scroll"><m:mrow><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>,</m:mo><m:mi>b</m:mi><m:mo>)</m:mo></m:mrow></m:math> with respect to <m:math overflow="scroll"><m:mi>S</m:mi></m:math> to be the smallest of the functional margins of
the individual training examples. Denoted
by <m:math overflow="scroll"><m:mover accent="true"><m:mi>γ</m:mi><m:mo>^</m:mo></m:mover></m:math>, this can therefore be written:</para>
      <equation id="id64439"><m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mover accent="true">
              <m:mi>γ</m:mi>
              <m:mo>^</m:mo>
            </m:mover>
            <m:mo>=</m:mo>
            <m:munder>
              <m:mo movablelimits="true" form="prefix">min</m:mo>
              <m:mrow>
                <m:mi>i</m:mi>
                <m:mo>=</m:mo>
                <m:mn>1</m:mn>
                <m:mo>,</m:mo>
                <m:mo>...</m:mo>
                <m:mo>,</m:mo>
                <m:mi>m</m:mi>
              </m:mrow>
            </m:munder>

              <m:mover accent="true">
                <m:mi>γ</m:mi>
                <m:mo>^</m:mo>
              </m:mover>
            <m:msup>
              <m:mrow/>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>i</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
            </m:msup>

            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation><para id="id64505">Next, let's talk about <emphasis effect="bold">geometric margins</emphasis>. Consider the picture below:</para>
      <figure id="uid2"><media id="uid2_media" alt="measuring the distance from the line to each type of data point">
          <image mime-type="image/png" src="../../media/geometricMargin2.png" id="uid2_onlineimage" width="348"><!-- NOTE: attribute width changes image size online (pixels). original width is 348. --></image>
          <image mime-type="application/postscript" for="pdf" print-width="3.5in" src="../../media/geometricMargin2.eps" id="uid2_printimage"/>
        </media>
      </figure><para id="id64522">The decision boundary corresponding to <m:math overflow="scroll"><m:mrow><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>,</m:mo><m:mi>b</m:mi><m:mo>)</m:mo></m:mrow></m:math> is shown, along with the vector <m:math overflow="scroll"><m:mi>w</m:mi></m:math>. Note
that <m:math overflow="scroll"><m:mi>w</m:mi></m:math> is orthogonal (at <m:math overflow="scroll"><m:msup><m:mn>90</m:mn><m:mo>∘</m:mo></m:msup></m:math>) to the separating hyperplane. (You should convince yourself
that this must be the case.) Consider the point at A, which represents the input <m:math overflow="scroll"><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup></m:math> of some
training example with label <m:math overflow="scroll"><m:mrow><m:msup><m:mi>y</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>=</m:mo><m:mn>1</m:mn></m:mrow></m:math>. Its distance to the decision boundary, <m:math overflow="scroll"><m:msup><m:mi>γ</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup></m:math>, is given
by the line segment AB.</para>
      <para id="id64643">How can we find the value of <m:math overflow="scroll"><m:msup><m:mi>γ</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup></m:math>? Well, <m:math overflow="scroll"><m:mrow><m:mi>w</m:mi><m:mo>/</m:mo><m:mo>|</m:mo><m:mo>|</m:mo><m:mi>w</m:mi><m:mo>|</m:mo><m:mo>|</m:mo></m:mrow></m:math> is a unit-length vector pointing in the same
direction as <m:math overflow="scroll"><m:mi>w</m:mi></m:math>.
Since <m:math overflow="scroll"><m:mi>A</m:mi></m:math> represents <m:math overflow="scroll"><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup></m:math>, we therefore find that the
point <m:math overflow="scroll"><m:mi>B</m:mi></m:math> is given by <m:math overflow="scroll"><m:mrow><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>-</m:mo><m:msup><m:mi>γ</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>·</m:mo><m:mi>w</m:mi><m:mo>/</m:mo><m:mrow><m:mo>|</m:mo><m:mo>|</m:mo><m:mi>w</m:mi><m:mo>|</m:mo><m:mo>|</m:mo></m:mrow></m:mrow></m:math>. But this point
lies on the decision boundary, and all points <m:math overflow="scroll"><m:mi>x</m:mi></m:math> on the decision boundary satisfy the equation
<m:math overflow="scroll"><m:mrow><m:msup><m:mi>w</m:mi><m:mi>T</m:mi></m:msup><m:mi>x</m:mi><m:mo>+</m:mo><m:mi>b</m:mi><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow></m:math>. Hence,</para>
      <equation id="id64824">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:msup>
              <m:mi>w</m:mi>
              <m:mi>T</m:mi>
            </m:msup>
            <m:mfenced separators="" open="(" close=")">
              <m:msup>
                <m:mi>x</m:mi>
                <m:mrow>
                  <m:mo>(</m:mo>
                  <m:mi>i</m:mi>
                  <m:mo>)</m:mo>
                </m:mrow>
              </m:msup>
              <m:mo>-</m:mo>
              <m:msup>
                <m:mi>γ</m:mi>
                <m:mrow>
                  <m:mo>(</m:mo>
                  <m:mi>i</m:mi>
                  <m:mo>)</m:mo>
                </m:mrow>
              </m:msup>
              <m:mfrac>
                <m:mi>w</m:mi>
                <m:mrow>
                  <m:mo>|</m:mo>
                  <m:mo>|</m:mo>
                  <m:mi>w</m:mi>
                  <m:mo>|</m:mo>
                  <m:mo>|</m:mo>
                </m:mrow>
              </m:mfrac>
            </m:mfenced>
            <m:mo>+</m:mo>
            <m:mi>b</m:mi>
            <m:mo>=</m:mo>
            <m:mn>0</m:mn>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id64903">Solving for <m:math overflow="scroll"><m:msup><m:mi>γ</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup></m:math> yields</para>
      <equation id="id64929">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:msup>
              <m:mi>γ</m:mi>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>i</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
            </m:msup>
            <m:mo>=</m:mo>
            <m:mfrac>
              <m:mrow>
                <m:msup>
                  <m:mi>w</m:mi>
                  <m:mi>T</m:mi>
                </m:msup>
                <m:msup>
                  <m:mi>x</m:mi>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mi>i</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                </m:msup>
                <m:mo>+</m:mo>
                <m:mi>b</m:mi>
              </m:mrow>
              <m:mrow>
                <m:mo>|</m:mo>
                <m:mo>|</m:mo>
                <m:mi>w</m:mi>
                <m:mo>|</m:mo>
                <m:mo>|</m:mo>
              </m:mrow>
            </m:mfrac>
            <m:mo>=</m:mo>
            <m:msup>
              <m:mfenced separators="" open="(" close=")">
                <m:mfrac>
                  <m:mi>w</m:mi>
                  <m:mrow>
                    <m:mo>|</m:mo>
                    <m:mo>|</m:mo>
                    <m:mi>w</m:mi>
                    <m:mo>|</m:mo>
                    <m:mo>|</m:mo>
                  </m:mrow>
                </m:mfrac>
              </m:mfenced>
              <m:mi>T</m:mi>
            </m:msup>
            <m:msup>
              <m:mi>x</m:mi>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>i</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
            </m:msup>
            <m:mo>+</m:mo>
            <m:mfrac>
              <m:mi>b</m:mi>
              <m:mrow>
                <m:mo>|</m:mo>
                <m:mo>|</m:mo>
                <m:mi>w</m:mi>
                <m:mo>|</m:mo>
                <m:mo>|</m:mo>
              </m:mrow>
            </m:mfrac>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id65057">This was worked out for the case of a positive training example at A in the figure, where being
on the “positive” side of the decision boundary is good. More generally, we define the geometric
margin of <m:math overflow="scroll"><m:mrow><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>,</m:mo><m:mi>b</m:mi><m:mo>)</m:mo></m:mrow></m:math> with respect to a training example <m:math overflow="scroll"><m:mrow><m:mo>(</m:mo><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>,</m:mo><m:msup><m:mi>y</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>)</m:mo></m:mrow></m:math> to be</para>
      <equation id="id65124">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:msup>
              <m:mi>γ</m:mi>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>i</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
            </m:msup>
            <m:mo>=</m:mo>
            <m:msup>
              <m:mi>y</m:mi>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>i</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
            </m:msup>
            <m:mfenced separators="" open="(" close=")">
              <m:msup>
                <m:mfenced separators="" open="(" close=")">
                  <m:mfrac>
                    <m:mi>w</m:mi>
                    <m:mrow>
                      <m:mo>|</m:mo>
                      <m:mo>|</m:mo>
                      <m:mi>w</m:mi>
                      <m:mo>|</m:mo>
                      <m:mo>|</m:mo>
                    </m:mrow>
                  </m:mfrac>
                </m:mfenced>
                <m:mi>T</m:mi>
              </m:msup>
              <m:msup>
                <m:mi>x</m:mi>
                <m:mrow>
                  <m:mo>(</m:mo>
                  <m:mi>i</m:mi>
                  <m:mo>)</m:mo>
                </m:mrow>
              </m:msup>
              <m:mo>+</m:mo>
              <m:mfrac>
                <m:mi>b</m:mi>
                <m:mrow>
                  <m:mo>|</m:mo>
                  <m:mo>|</m:mo>
                  <m:mi>w</m:mi>
                  <m:mo>|</m:mo>
                  <m:mo>|</m:mo>
                </m:mrow>
              </m:mfrac>
            </m:mfenced>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id65233">Note that if <m:math overflow="scroll"><m:mrow><m:mo>|</m:mo><m:mo>|</m:mo><m:mi>w</m:mi><m:mo>|</m:mo><m:mo>|</m:mo><m:mo>=</m:mo><m:mn>1</m:mn></m:mrow></m:math>, then the functional margin equals the geometric margin—this thus gives
us a way of relating these two different notions of margin. Also, the geometric margin
is invariant to rescaling of the parameters; i.e., if we replace <m:math overflow="scroll"><m:mi>w</m:mi></m:math> with <m:math overflow="scroll"><m:mrow><m:mn>2</m:mn><m:mi>w</m:mi></m:mrow></m:math> and <m:math overflow="scroll"><m:mi>b</m:mi></m:math> with <m:math overflow="scroll"><m:mrow><m:mn>2</m:mn><m:mi>b</m:mi></m:mrow></m:math>, then
the geometric margin does not change.
This will in fact come in handy later. Specifically, because of this invariance to the scaling of the parameters,
when trying to fit <m:math overflow="scroll"><m:mi>w</m:mi></m:math> and <m:math overflow="scroll"><m:mi>b</m:mi></m:math> to training data, we can impose an arbitrary scaling constraint on <m:math overflow="scroll"><m:mi>w</m:mi></m:math> without
changing anything important; for instance, we can demand that <m:math overflow="scroll"><m:mrow><m:mo>|</m:mo><m:mo>|</m:mo><m:mi>w</m:mi><m:mo>|</m:mo><m:mo>|</m:mo><m:mo>=</m:mo><m:mn>1</m:mn></m:mrow></m:math>, or <m:math overflow="scroll"><m:mrow><m:mrow><m:mo>|</m:mo></m:mrow><m:msub><m:mi>w</m:mi><m:mn>1</m:mn></m:msub><m:mrow><m:mo>|</m:mo><m:mo>=</m:mo><m:mn>5</m:mn></m:mrow></m:mrow></m:math>,
or <m:math overflow="scroll"><m:mrow><m:mrow><m:mo>|</m:mo></m:mrow><m:msub><m:mi>w</m:mi><m:mn>1</m:mn></m:msub><m:mrow><m:mo>+</m:mo><m:mi>b</m:mi><m:mo>|</m:mo><m:mo>+</m:mo><m:mo>|</m:mo></m:mrow><m:msub><m:mi>w</m:mi><m:mn>2</m:mn></m:msub><m:mrow><m:mo>|</m:mo><m:mo>=</m:mo><m:mn>2</m:mn></m:mrow></m:mrow></m:math>, and any of these can be satisfied simply by rescaling <m:math overflow="scroll"><m:mi>w</m:mi></m:math> and <m:math overflow="scroll"><m:mi>b</m:mi></m:math>.</para>
      <para id="id65444">Finally, given a training set <m:math overflow="scroll"><m:mrow><m:mi>S</m:mi><m:mo>=</m:mo><m:mo>{</m:mo><m:mrow><m:mo>(</m:mo><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>,</m:mo><m:msup><m:mi>y</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>)</m:mo></m:mrow><m:mo>;</m:mo><m:mi>i</m:mi><m:mo>=</m:mo><m:mn>1</m:mn><m:mo>,</m:mo><m:mo>...</m:mo><m:mo>,</m:mo><m:mi>m</m:mi><m:mo>}</m:mo></m:mrow></m:math>, we also define
the geometric margin of <m:math overflow="scroll"><m:mrow><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>,</m:mo><m:mi>b</m:mi><m:mo>)</m:mo></m:mrow></m:math> with respect to <m:math overflow="scroll"><m:mi>S</m:mi></m:math> to be the smallest of the geometric margins on the
individual training examples:</para>
      <equation id="id65542">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mi>γ</m:mi>
            <m:mo>=</m:mo>
            <m:munder>
              <m:mo movablelimits="true" form="prefix">min</m:mo>
              <m:mrow>
                <m:mi>i</m:mi>
                <m:mo>=</m:mo>
                <m:mn>1</m:mn>
                <m:mo>,</m:mo>
                <m:mo>...</m:mo>
                <m:mo>,</m:mo>
                <m:mi>m</m:mi>
              </m:mrow>
            </m:munder>
            <m:msup>
              <m:mi>γ</m:mi>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>i</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
            </m:msup>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
    </section>
    <section id="cid5">
      <title>The optimal margin classifier</title>
      <para id="id65607">Given a training set, it seems from our previous discussion that a natural desideratum
is to try to find a decision boundary that maximizes the (geometric) margin, since this
would reflect a very confident set of predictions on the training set and a good “fit” to
the training data. Specifically, this will result in a classifier that separates the positive
and the negative training examples with a “gap” (geometric margin).</para>
      <para id="id65617">For now, we will assume that we are given a training set that is linearly separable; i.e., that
it is possible to separate the positive and negative examples using some separating hyperplane.
How we we find the one that achieves the maximum geometric margin? We can pose the following optimization
problem:</para>
      <equation id="id65623">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:msub>
                  <m:mtext>max</m:mtext>
                  <m:mrow>
                    <m:mi>γ</m:mi>
                    <m:mo>,</m:mo>
                    <m:mi>w</m:mi>
                    <m:mo>,</m:mo>
                    <m:mi>b</m:mi>
                  </m:mrow>
                </m:msub>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mi>γ</m:mi>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mrow>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mtext>s.t.</m:mtext>
                </m:mrow>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:msup>
                    <m:mi>y</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>i</m:mi>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:msup>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msup>
                      <m:mi>w</m:mi>
                      <m:mi>T</m:mi>
                    </m:msup>
                    <m:msup>
                      <m:mi>x</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>i</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msup>
                    <m:mo>+</m:mo>
                    <m:mi>b</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>≥</m:mo>
                  <m:mi>γ</m:mi>
                  <m:mo>,</m:mo>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mi>i</m:mi>
                  <m:mo>=</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>,</m:mo>
                  <m:mo>...</m:mo>
                  <m:mo>,</m:mo>
                  <m:mi>m</m:mi>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd/>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mo>|</m:mo>
                  <m:mo>|</m:mo>
                  <m:mi>w</m:mi>
                  <m:mo>|</m:mo>
                  <m:mo>|</m:mo>
                  <m:mo>=</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>.</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id65792">I.e., we want to maximize <m:math overflow="scroll"><m:mi>γ</m:mi></m:math>, subject to each training example having functional margin at least <m:math overflow="scroll"><m:mi>γ</m:mi></m:math>.
The <m:math overflow="scroll"><m:mrow><m:mo>|</m:mo><m:mo>|</m:mo><m:mi>w</m:mi><m:mo>|</m:mo><m:mo>|</m:mo><m:mo>=</m:mo><m:mn>1</m:mn></m:mrow></m:math> constraint moreover ensures that the functional margin equals to the geometric margin, so
we are also guaranteed that all the geometric margins are at least <m:math overflow="scroll"><m:mi>γ</m:mi></m:math>.
Thus, solving this problem will result in <m:math overflow="scroll"><m:mrow><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>,</m:mo><m:mi>b</m:mi><m:mo>)</m:mo></m:mrow></m:math> with the largest possible geometric margin
with respect to the training set.</para>
      <para id="id65869">If we could solve the optimization problem above, we'd be done. But the “<m:math overflow="scroll"><m:mrow><m:mo>|</m:mo><m:mo>|</m:mo><m:mi>w</m:mi><m:mo>|</m:mo><m:mo>|</m:mo><m:mo>=</m:mo><m:mn>1</m:mn></m:mrow></m:math>” constraint is a nasty
(non-convex) one, and this problem certainly isn't in any format that we can plug into standard optimization
software to solve. So, let's try transforming the problem into a nicer one. Consider:</para>
      <equation id="id65898">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:msub>
                  <m:mtext>max</m:mtext>
                  <m:mrow>
                    <m:mi>γ</m:mi>
                    <m:mo>,</m:mo>
                    <m:mi>w</m:mi>
                    <m:mo>,</m:mo>
                    <m:mi>b</m:mi>
                  </m:mrow>
                </m:msub>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mfrac>
                  <m:mover accent="true">
                    <m:mi>γ</m:mi>
                    <m:mo>^</m:mo>
                  </m:mover>
                  <m:mrow>
                    <m:mo>|</m:mo>
                    <m:mo>|</m:mo>
                    <m:mi>w</m:mi>
                    <m:mo>|</m:mo>
                    <m:mo>|</m:mo>
                  </m:mrow>
                </m:mfrac>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mrow>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mtext>s.t.</m:mtext>
                </m:mrow>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:msup>
                    <m:mi>y</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>i</m:mi>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:msup>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msup>
                      <m:mi>w</m:mi>
                      <m:mi>T</m:mi>
                    </m:msup>
                    <m:msup>
                      <m:mi>x</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>i</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msup>
                    <m:mo>+</m:mo>
                    <m:mi>b</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>≥</m:mo>
                  <m:mover accent="true">
                    <m:mi>γ</m:mi>
                    <m:mo>^</m:mo>
                  </m:mover>
                  <m:mo>,</m:mo>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mi>i</m:mi>
                  <m:mo>=</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>,</m:mo>
                  <m:mo>...</m:mo>
                  <m:mo>,</m:mo>
                  <m:mi>m</m:mi>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id66069">Here, we're going to maximize <m:math overflow="scroll"><m:mrow><m:mover accent="true"><m:mi>γ</m:mi><m:mo>^</m:mo></m:mover><m:mo>/</m:mo><m:mrow><m:mo>|</m:mo><m:mo>|</m:mo><m:mi>w</m:mi><m:mo>|</m:mo><m:mo>|</m:mo></m:mrow></m:mrow></m:math>, subject to the functional margins all
being at least <m:math overflow="scroll"><m:mover accent="true"><m:mi>γ</m:mi><m:mo>^</m:mo></m:mover></m:math>. Since the geometric and functional margins are related by
<m:math overflow="scroll"><m:mrow><m:mi>γ</m:mi><m:mo>=</m:mo><m:mover accent="true"><m:mi>γ</m:mi><m:mo>^</m:mo></m:mover><m:mo>/</m:mo><m:mrow><m:mo>|</m:mo><m:mo>|</m:mo><m:mi>w</m:mi><m:mo>|</m:mo><m:mo>|</m:mo></m:mrow></m:mrow></m:math>, this will give us the answer we want. Moreover, we've gotten
rid of the constraint <m:math overflow="scroll"><m:mrow><m:mo>|</m:mo><m:mo>|</m:mo><m:mi>w</m:mi><m:mo>|</m:mo><m:mo>|</m:mo><m:mo>=</m:mo><m:mn>1</m:mn></m:mrow></m:math> that we didn't like. The downside is that we now
have a nasty (again, non-convex) objective <m:math overflow="scroll"><m:mfrac><m:mover accent="true"><m:mi>γ</m:mi><m:mo>^</m:mo></m:mover><m:mrow><m:mo>|</m:mo><m:mo>|</m:mo><m:mi>w</m:mi><m:mo>|</m:mo><m:mo>|</m:mo></m:mrow></m:mfrac></m:math> function; and,
we still don't have any off-the-shelf software that can solve this form of an optimization problem.</para><para id="id66209">Let's keep going. Recall our earlier discussion that we can add an arbitrary scaling constraint
on <m:math overflow="scroll"><m:mi>w</m:mi></m:math> and <m:math overflow="scroll"><m:mi>b</m:mi></m:math> without changing anything. This is the key idea we'll use now. We will introduce the scaling
constraint that the functional margin of <m:math overflow="scroll"><m:mrow><m:mi>w</m:mi><m:mo>,</m:mo><m:mi>b</m:mi></m:mrow></m:math> with respect to the training set must be 1:</para>
      <equation id="id66247">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mover accent="true">
              <m:mi>γ</m:mi>
              <m:mo>^</m:mo>
            </m:mover>
            <m:mo>=</m:mo>
            <m:mn>1</m:mn>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id66272">Since multiplying <m:math overflow="scroll"><m:mi>w</m:mi></m:math> and <m:math overflow="scroll"><m:mi>b</m:mi></m:math> by some constant results in the functional margin being multiplied
by that same constant, this is indeed a scaling constraint, and can be satisfied by rescaling <m:math overflow="scroll"><m:mrow><m:mi>w</m:mi><m:mo>,</m:mo><m:mi>b</m:mi></m:mrow></m:math>.
Plugging this into our problem above, and noting that maximizing
<m:math overflow="scroll"><m:mrow><m:mover accent="true"><m:mi>γ</m:mi><m:mo>^</m:mo></m:mover><m:mo>/</m:mo><m:mrow><m:mo>|</m:mo><m:mo>|</m:mo><m:mi>w</m:mi><m:mo>|</m:mo><m:mo>|</m:mo></m:mrow></m:mrow></m:math> = <m:math overflow="scroll"><m:mrow><m:mn>1</m:mn><m:mo>/</m:mo><m:mo>|</m:mo><m:mo>|</m:mo><m:mi>w</m:mi><m:mo>|</m:mo><m:mo>|</m:mo></m:mrow></m:math>
is the
same thing as minimizing <m:math overflow="scroll"><m:msup><m:mrow><m:mo>|</m:mo><m:mo>|</m:mo><m:mi>w</m:mi><m:mo>|</m:mo><m:mo>|</m:mo></m:mrow><m:mn>2</m:mn></m:msup></m:math>, we now have the following optimization problem:</para>
      <equation id="id66388">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:msub>
                  <m:mtext>min</m:mtext>
                  <m:mrow>
                    <m:mi>γ</m:mi>
                    <m:mo>,</m:mo>
                    <m:mi>w</m:mi>
                    <m:mo>,</m:mo>
                    <m:mi>b</m:mi>
                  </m:mrow>
                </m:msub>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mfrac>
                    <m:mn>1</m:mn>
                    <m:mn>2</m:mn>
                  </m:mfrac>
                  <m:msup>
                    <m:mrow>
                      <m:mo>|</m:mo>
                      <m:mo>|</m:mo>
                      <m:mi>w</m:mi>
                      <m:mo>|</m:mo>
                      <m:mo>|</m:mo>
                    </m:mrow>
                    <m:mn>2</m:mn>
                  </m:msup>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mrow>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mtext>s.t.</m:mtext>
                </m:mrow>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:msup>
                    <m:mi>y</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>i</m:mi>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:msup>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msup>
                      <m:mi>w</m:mi>
                      <m:mi>T</m:mi>
                    </m:msup>
                    <m:msup>
                      <m:mi>x</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>i</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msup>
                    <m:mo>+</m:mo>
                    <m:mi>b</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>≥</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>,</m:mo>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mi>i</m:mi>
                  <m:mo>=</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>,</m:mo>
                  <m:mo>...</m:mo>
                  <m:mo>,</m:mo>
                  <m:mi>m</m:mi>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id66554">We've now transformed the problem into a form that can be efficiently solved. The above is an
optimization problem with a convex quadratic objective and only linear constraints. Its
solution gives us the <emphasis effect="bold">optimal margin classifier</emphasis>. This optimization problem can
be solved using commercial quadratic programming (QP) code.<footnote id="uid3">You may be familiar with
linear programming, which solves optimization problems that have linear objectives and
linear constraints. QP software is also widely available, which allows convex quadratic
objectives and linear constraints.</footnote></para>
      <para id="id66577">While we could call the problem solved here, what we will instead do is make a
digression to talk about Lagrange duality. This will lead us to our optimization problem's
dual form, which will play a key role in allowing us to use kernels to get optimal
margin classifiers to work efficiently in very high dimensional spaces. The dual form
will also allow us to derive an efficient algorithm for solving the above optimization
problem that will typically do much better than generic QP software.</para>
    </section>
    <section id="cid6">
      <title>Lagrange duality</title>
      <para id="id66594">Let's temporarily put aside SVMs and maximum margin classifiers, and talk about solving
constrained optimization problems.</para>
      <para id="id66598">Consider a problem of the following form:</para>
      <equation id="id66602">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:msub>
                  <m:mtext>min</m:mtext>
                  <m:mi>w</m:mi>
                </m:msub>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mi>f</m:mi>
                  <m:mo>(</m:mo>
                  <m:mi>w</m:mi>
                  <m:mo>)</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mrow>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mtext>s.t.</m:mtext>
                </m:mrow>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:msub>
                    <m:mi>h</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mi>w</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>=</m:mo>
                  <m:mn>0</m:mn>
                  <m:mo>,</m:mo>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mi>i</m:mi>
                  <m:mo>=</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>,</m:mo>
                  <m:mo>...</m:mo>
                  <m:mo>,</m:mo>
                  <m:mi>l</m:mi>
                  <m:mo>.</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id66717">Some of you may recall how the method of Lagrange multipliers can be used to solve it.
(Don't worry if you haven't seen it before.) In this method, we define
the <emphasis effect="bold">Lagrangian</emphasis> to be</para>
      <equation id="id66730">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mi mathvariant="script">L</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>,</m:mo>
              <m:mi>β</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:mi>f</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>+</m:mo>
            <m:munderover>
              <m:mo>∑</m:mo>
              <m:mrow>
                <m:mi>i</m:mi>
                <m:mo>=</m:mo>
                <m:mn>1</m:mn>
              </m:mrow>
              <m:mi>l</m:mi>
            </m:munderover>
            <m:msub>
              <m:mi>β</m:mi>
              <m:mi>i</m:mi>
            </m:msub>
            <m:msub>
              <m:mi>h</m:mi>
              <m:mi>i</m:mi>
            </m:msub>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id66809">Here, the <m:math overflow="scroll"><m:msub><m:mi>β</m:mi><m:mi>i</m:mi></m:msub></m:math>'s are called the <emphasis effect="bold">Lagrange multipliers</emphasis>. We would then find and
set <m:math overflow="scroll"><m:mi mathvariant="script">L</m:mi></m:math>'s partial derivatives to zero:</para>
      <equation id="id66848">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mfrac>
              <m:mrow>
                <m:mi>∂</m:mi>
                <m:mi mathvariant="script">L</m:mi>
              </m:mrow>
              <m:mrow>
                <m:mi>∂</m:mi>
                <m:msub>
                  <m:mi>w</m:mi>
                  <m:mi>i</m:mi>
                </m:msub>
              </m:mrow>
            </m:mfrac>
            <m:mo>=</m:mo>
            <m:mn>0</m:mn>
            <m:mo>;</m:mo>
            <m:mspace width="0.277778em"/>
            <m:mspace width="0.277778em"/>
            <m:mfrac>
              <m:mrow>
                <m:mi>∂</m:mi>
                <m:mi mathvariant="script">L</m:mi>
              </m:mrow>
              <m:mrow>
                <m:mi>∂</m:mi>
                <m:msub>
                  <m:mi>β</m:mi>
                  <m:mi>i</m:mi>
                </m:msub>
              </m:mrow>
            </m:mfrac>
            <m:mo>=</m:mo>
            <m:mn>0</m:mn>
            <m:mo>,</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id66918">and solve for <m:math overflow="scroll"><m:mi>w</m:mi></m:math> and <m:math overflow="scroll"><m:mi>β</m:mi></m:math>.</para>
      <para id="id66942">In this section, we will generalize this to constrained optimization problems in which we may
have inequality as well as equality constraints. Due to time constraints, we won't really be
able to do the theory of Lagrange duality justice in this class,<footnote id="uid4">Readers interested in learning more
about this topic are encouraged to read, e.g., R. T. Rockarfeller (1970), Convex Analysis,
Princeton University Press.</footnote> but we will give the main ideas and results, which we will then
apply to our optimal margin classifier's optimization problem.</para>
      <para id="id66960">Consider the following, which we'll call the <emphasis effect="bold">primal</emphasis> optimization problem:</para>
      <equation id="id66969">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:msub>
                  <m:mtext>min</m:mtext>
                  <m:mi>w</m:mi>
                </m:msub>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mi>f</m:mi>
                  <m:mo>(</m:mo>
                  <m:mi>w</m:mi>
                  <m:mo>)</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mrow>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mtext>s.t.</m:mtext>
                </m:mrow>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:msub>
                    <m:mi>g</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mi>w</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>≤</m:mo>
                  <m:mn>0</m:mn>
                  <m:mo>,</m:mo>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mi>i</m:mi>
                  <m:mo>=</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>,</m:mo>
                  <m:mo>...</m:mo>
                  <m:mo>,</m:mo>
                  <m:mi>k</m:mi>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd/>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:msub>
                    <m:mi>h</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mi>w</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>=</m:mo>
                  <m:mn>0</m:mn>
                  <m:mo>,</m:mo>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mi>i</m:mi>
                  <m:mo>=</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>,</m:mo>
                  <m:mo>...</m:mo>
                  <m:mo>,</m:mo>
                  <m:mi>l</m:mi>
                  <m:mo>.</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id67135">To solve it, we start by defining the <emphasis effect="bold">generalized Lagrangian</emphasis></para>
      <equation id="id67146">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mi mathvariant="script">L</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>,</m:mo>
              <m:mi>α</m:mi>
              <m:mo>,</m:mo>
              <m:mi>β</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:mi>f</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>+</m:mo>
            <m:munderover>
              <m:mo>∑</m:mo>
              <m:mrow>
                <m:mi>i</m:mi>
                <m:mo>=</m:mo>
                <m:mn>1</m:mn>
              </m:mrow>
              <m:mi>k</m:mi>
            </m:munderover>
            <m:msub>
              <m:mi>α</m:mi>
              <m:mi>i</m:mi>
            </m:msub>
            <m:msub>
              <m:mi>g</m:mi>
              <m:mi>i</m:mi>
            </m:msub>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>+</m:mo>
            <m:munderover>
              <m:mo>∑</m:mo>
              <m:mrow>
                <m:mi>i</m:mi>
                <m:mo>=</m:mo>
                <m:mn>1</m:mn>
              </m:mrow>
              <m:mi>l</m:mi>
            </m:munderover>
            <m:msub>
              <m:mi>β</m:mi>
              <m:mi>i</m:mi>
            </m:msub>
            <m:msub>
              <m:mi>h</m:mi>
              <m:mi>i</m:mi>
            </m:msub>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id67272">Here, the <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mi>i</m:mi></m:msub></m:math>'s and <m:math overflow="scroll"><m:msub><m:mi>β</m:mi><m:mi>i</m:mi></m:msub></m:math>'s are the Lagrange multipliers.
Consider the quantity</para>
      <equation id="id67308">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:msub>
              <m:mi>θ</m:mi>
              <m:mi mathvariant="script">P</m:mi>
            </m:msub>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:munder>
              <m:mo movablelimits="true" form="prefix">max</m:mo>
              <m:mrow>
                <m:mi>α</m:mi>
                <m:mo>,</m:mo>
                <m:mi>β</m:mi>
                <m:mspace width="0.166667em"/>
                <m:mo>:</m:mo>
                <m:mspace width="0.166667em"/>
                <m:msub>
                  <m:mi>α</m:mi>
                  <m:mi>i</m:mi>
                </m:msub>
                <m:mo>≥</m:mo>
                <m:mn>0</m:mn>
              </m:mrow>
            </m:munder>
            <m:mi mathvariant="script">L</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>,</m:mo>
              <m:mi>α</m:mi>
              <m:mo>,</m:mo>
              <m:mi>β</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id67399">Here, the “<m:math overflow="scroll"><m:mi mathvariant="script">P</m:mi></m:math>” subscript stands for “primal.” Let some <m:math overflow="scroll"><m:mi>w</m:mi></m:math> be given. If <m:math overflow="scroll"><m:mi>w</m:mi></m:math> violates
any of the primal constraints (i.e., if either <m:math overflow="scroll"><m:mrow><m:msub><m:mi>g</m:mi><m:mi>i</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>)</m:mo></m:mrow><m:mo>&gt;</m:mo><m:mn>0</m:mn></m:mrow></m:math> or <m:math overflow="scroll"><m:mrow><m:msub><m:mi>h</m:mi><m:mi>i</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>)</m:mo></m:mrow><m:mo>≠</m:mo><m:mn>0</m:mn></m:mrow></m:math> for some <m:math overflow="scroll"><m:mi>i</m:mi></m:math>), then
you should be able to verify that</para>
      <equation id="uid5">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:msub>
                    <m:mi>θ</m:mi>
                    <m:mi mathvariant="script">P</m:mi>
                  </m:msub>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mi>w</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                </m:mrow>
              </m:mtd>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:munder>
                    <m:mo movablelimits="true" form="prefix">max</m:mo>
                    <m:mrow>
                      <m:mi>α</m:mi>
                      <m:mo>,</m:mo>
                      <m:mi>β</m:mi>
                      <m:mspace width="0.166667em"/>
                      <m:mo>:</m:mo>
                      <m:mspace width="0.166667em"/>
                      <m:msub>
                        <m:mi>α</m:mi>
                        <m:mi>i</m:mi>
                      </m:msub>
                      <m:mo>≥</m:mo>
                      <m:mn>0</m:mn>
                    </m:mrow>
                  </m:munder>
                  <m:mi>f</m:mi>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mi>w</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>+</m:mo>
                  <m:munderover>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:mi>i</m:mi>
                      <m:mo>=</m:mo>
                      <m:mn>1</m:mn>
                    </m:mrow>
                    <m:mi>k</m:mi>
                  </m:munderover>
                  <m:msub>
                    <m:mi>α</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:msub>
                    <m:mi>g</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mi>w</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>+</m:mo>
                  <m:munderover>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:mi>i</m:mi>
                      <m:mo>=</m:mo>
                      <m:mn>1</m:mn>
                    </m:mrow>
                    <m:mi>l</m:mi>
                  </m:munderover>
                  <m:msub>
                    <m:mi>β</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:msub>
                    <m:mi>h</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mi>w</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mi>∞</m:mi>
                  <m:mo>.</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id67689">Conversely, if the constraints are indeed satisfied for a particular value of <m:math overflow="scroll"><m:mi>w</m:mi></m:math>, then <m:math overflow="scroll"><m:mrow><m:msub><m:mi>θ</m:mi><m:mi mathvariant="script">P</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mi>f</m:mi><m:mrow><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:math>. Hence,</para>
      <equation id="id67742">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:msub>
              <m:mi>θ</m:mi>
              <m:mi mathvariant="script">P</m:mi>
            </m:msub>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:mfenced separators="" open="{" close="">
              <m:mtable>
                <m:mtr>
                  <m:mtd columnalign="left">
                    <m:mrow>
                      <m:mi>f</m:mi>
                      <m:mo>(</m:mo>
                      <m:mi>w</m:mi>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:mtd>
                  <m:mtd columnalign="left">
                    <m:mrow>
                      <m:mtext>if</m:mtext>
                      <m:mspace width="4.pt"/>
                      <m:mi>w</m:mi>
                      <m:mspace width="4.pt"/>
                      <m:mtext>satisfies</m:mtext>
                      <m:mspace width="4.pt"/>
                      <m:mtext>primal</m:mtext>
                      <m:mspace width="4.pt"/>
                      <m:mtext>constraints</m:mtext>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>
                <m:mtr>
                  <m:mtd columnalign="left">
                    <m:mi>∞</m:mi>
                  </m:mtd>
                  <m:mtd columnalign="left">
                    <m:mrow>
                      <m:mtext>otherwise</m:mtext>
                      <m:mo>.</m:mo>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>
              </m:mtable>
            </m:mfenced>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id67838">Thus, <m:math overflow="scroll"><m:msub><m:mi>θ</m:mi><m:mi mathvariant="script">P</m:mi></m:msub></m:math> takes the same value as the objective in our problem for all values of <m:math overflow="scroll"><m:mi>w</m:mi></m:math> that
satisfies the primal constraints, and is positive infinity if the constraints are violated. Hence, if we
consider the minimization problem</para>
      <equation id="id67872">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:munder>
              <m:mo movablelimits="true" form="prefix">min</m:mo>
              <m:mi>w</m:mi>
            </m:munder>
            <m:msub>
              <m:mi>θ</m:mi>
              <m:mi mathvariant="script">P</m:mi>
            </m:msub>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:munder>
              <m:mo movablelimits="true" form="prefix">min</m:mo>
              <m:mi>w</m:mi>
            </m:munder>
            <m:munder>
              <m:mo movablelimits="true" form="prefix">max</m:mo>
              <m:mrow>
                <m:mi>α</m:mi>
                <m:mo>,</m:mo>
                <m:mi>β</m:mi>
                <m:mspace width="0.166667em"/>
                <m:mo>:</m:mo>
                <m:mspace width="0.166667em"/>
                <m:msub>
                  <m:mi>α</m:mi>
                  <m:mi>i</m:mi>
                </m:msub>
                <m:mo>≥</m:mo>
                <m:mn>0</m:mn>
              </m:mrow>
            </m:munder>
            <m:mi mathvariant="script">L</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>,</m:mo>
              <m:mi>α</m:mi>
              <m:mo>,</m:mo>
              <m:mi>β</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>,</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id67986">we see that it is the same problem (i.e., and has the same solutions as) our original, primal problem.
For later use, we also define the optimal value of the objective to
be <m:math overflow="scroll"><m:mrow><m:msup><m:mi>p</m:mi><m:mo>*</m:mo></m:msup><m:mo>=</m:mo><m:msub><m:mo movablelimits="true" form="prefix">min</m:mo><m:mi>w</m:mi></m:msub><m:msub><m:mi>θ</m:mi><m:mi mathvariant="script">P</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:math>;
we call this the <emphasis effect="bold">value</emphasis> of the primal problem.</para>
      <para id="id68046">Now, let's look at a slightly different problem. We define</para>
      <equation id="id68050">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:msub>
              <m:mi>θ</m:mi>
              <m:mi mathvariant="script">D</m:mi>
            </m:msub>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>α</m:mi>
              <m:mo>,</m:mo>
              <m:mi>β</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:munder>
              <m:mo movablelimits="true" form="prefix">min</m:mo>
              <m:mi>w</m:mi>
            </m:munder>
            <m:mi mathvariant="script">L</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>,</m:mo>
              <m:mi>α</m:mi>
              <m:mo>,</m:mo>
              <m:mi>β</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id68119">Here, the “<m:math overflow="scroll"><m:mi mathvariant="script">D</m:mi></m:math>” subscript stands for “dual.” Note also that whereas in the
definition of <m:math overflow="scroll"><m:msub><m:mi>θ</m:mi><m:mi mathvariant="script">P</m:mi></m:msub></m:math> we were optimizing (maximizing) with respect to <m:math overflow="scroll"><m:mrow><m:mi>α</m:mi><m:mo>,</m:mo><m:mi>β</m:mi></m:mrow></m:math>,
here are are minimizing with respect to <m:math overflow="scroll"><m:mi>w</m:mi></m:math>.</para>
      <para id="id68178">We can now pose the <emphasis effect="bold">dual</emphasis> optimization problem:</para>
      <equation id="id68187">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:munder>
              <m:mo movablelimits="true" form="prefix">max</m:mo>
              <m:mrow>
                <m:mi>α</m:mi>
                <m:mo>,</m:mo>
                <m:mi>β</m:mi>
                <m:mspace width="0.166667em"/>
                <m:mo>:</m:mo>
                <m:mspace width="0.166667em"/>
                <m:msub>
                  <m:mi>α</m:mi>
                  <m:mi>i</m:mi>
                </m:msub>
                <m:mo>≥</m:mo>
                <m:mn>0</m:mn>
              </m:mrow>
            </m:munder>
            <m:msub>
              <m:mi>θ</m:mi>
              <m:mi mathvariant="script">D</m:mi>
            </m:msub>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>α</m:mi>
              <m:mo>,</m:mo>
              <m:mi>β</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:munder>
              <m:mo movablelimits="true" form="prefix">max</m:mo>
              <m:mrow>
                <m:mi>α</m:mi>
                <m:mo>,</m:mo>
                <m:mi>β</m:mi>
                <m:mspace width="0.166667em"/>
                <m:mo>:</m:mo>
                <m:mspace width="0.166667em"/>
                <m:msub>
                  <m:mi>α</m:mi>
                  <m:mi>i</m:mi>
                </m:msub>
                <m:mo>≥</m:mo>
                <m:mn>0</m:mn>
              </m:mrow>
            </m:munder>
            <m:munder>
              <m:mo movablelimits="true" form="prefix">min</m:mo>
              <m:mi>w</m:mi>
            </m:munder>
            <m:mi mathvariant="script">L</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>,</m:mo>
              <m:mi>α</m:mi>
              <m:mo>,</m:mo>
              <m:mi>β</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id68334">This is exactly the same as our primal problem shown above, except that the order of the
“<m:math overflow="scroll"><m:mo movablelimits="true" form="prefix">max</m:mo></m:math>” and the “<m:math overflow="scroll"><m:mo movablelimits="true" form="prefix">min</m:mo></m:math>” are now exchanged. We also define the optimal value of the
dual problem's objective to be <m:math overflow="scroll"><m:mrow><m:msup><m:mi>d</m:mi><m:mo>*</m:mo></m:msup><m:mo>=</m:mo><m:msub><m:mo movablelimits="true" form="prefix">max</m:mo><m:mrow><m:mi>α</m:mi><m:mo>,</m:mo><m:mi>β</m:mi><m:mspace width="0.166667em"/><m:mo>:</m:mo><m:mspace width="0.166667em"/><m:msub><m:mi>α</m:mi><m:mi>i</m:mi></m:msub><m:mo>≥</m:mo><m:mn>0</m:mn></m:mrow></m:msub><m:msub><m:mi>θ</m:mi><m:mi mathvariant="script">D</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:math>.</para>
      <para id="id68442">How are the primal and the dual problems related? It can easily be shown that</para>
      <equation id="id68446">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:msup>
              <m:mi>d</m:mi>
              <m:mo>*</m:mo>
            </m:msup>
            <m:mo>=</m:mo>
            <m:munder>
              <m:mo movablelimits="true" form="prefix">max</m:mo>
              <m:mrow>
                <m:mi>α</m:mi>
                <m:mo>,</m:mo>
                <m:mi>β</m:mi>
                <m:mspace width="0.166667em"/>
                <m:mo>:</m:mo>
                <m:mspace width="0.166667em"/>
                <m:msub>
                  <m:mi>α</m:mi>
                  <m:mi>i</m:mi>
                </m:msub>
                <m:mo>≥</m:mo>
                <m:mn>0</m:mn>
              </m:mrow>
            </m:munder>
            <m:munder>
              <m:mo movablelimits="true" form="prefix">min</m:mo>
              <m:mi>w</m:mi>
            </m:munder>
            <m:mi mathvariant="script">L</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>,</m:mo>
              <m:mi>α</m:mi>
              <m:mo>,</m:mo>
              <m:mi>β</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>≤</m:mo>
            <m:munder>
              <m:mo movablelimits="true" form="prefix">min</m:mo>
              <m:mi>w</m:mi>
            </m:munder>
            <m:munder>
              <m:mo movablelimits="true" form="prefix">max</m:mo>
              <m:mrow>
                <m:mi>α</m:mi>
                <m:mo>,</m:mo>
                <m:mi>β</m:mi>
                <m:mspace width="0.166667em"/>
                <m:mo>:</m:mo>
                <m:mspace width="0.166667em"/>
                <m:msub>
                  <m:mi>α</m:mi>
                  <m:mi>i</m:mi>
                </m:msub>
                <m:mo>≥</m:mo>
                <m:mn>0</m:mn>
              </m:mrow>
            </m:munder>
            <m:mi mathvariant="script">L</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>,</m:mo>
              <m:mi>α</m:mi>
              <m:mo>,</m:mo>
              <m:mi>β</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:msup>
              <m:mi>p</m:mi>
              <m:mo>*</m:mo>
            </m:msup>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id68624">(You should convince yourself of this; this follows from the “<m:math overflow="scroll"><m:mrow><m:mo movablelimits="true" form="prefix">max</m:mo><m:mo movablelimits="true" form="prefix">min</m:mo></m:mrow></m:math>” of a
function always being less than or equal to the “<m:math overflow="scroll"><m:mrow><m:mo movablelimits="true" form="prefix">min</m:mo><m:mo movablelimits="true" form="prefix">max</m:mo></m:mrow></m:math>.”) However, under certain
conditions, we will have</para>
      <equation id="id68674">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:msup>
              <m:mi>d</m:mi>
              <m:mo>*</m:mo>
            </m:msup>
            <m:mo>=</m:mo>
            <m:msup>
              <m:mi>p</m:mi>
              <m:mo>*</m:mo>
            </m:msup>
            <m:mo>,</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id68704">so that we can solve the dual problem in lieu of the primal problem. Let's see what
these conditions are.</para>
      <para id="id68710">Suppose <m:math overflow="scroll"><m:mi>f</m:mi></m:math> and the <m:math overflow="scroll"><m:msub><m:mi>g</m:mi><m:mi>i</m:mi></m:msub></m:math>'s are convex,<footnote id="uid6">When <m:math overflow="scroll"><m:mi>f</m:mi></m:math> has a Hessian, then it is convex if
and only if the Hessian is positive semi-definite.
For instance, <m:math overflow="scroll"><m:mrow><m:mi>f</m:mi><m:mrow><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:msup><m:mi>w</m:mi><m:mi>T</m:mi></m:msup><m:mi>w</m:mi></m:mrow></m:math> is convex; similarly, all linear (and affine) functions are
also convex.
(A function <m:math overflow="scroll"><m:mi>f</m:mi></m:math> can also be convex without
being differentiable, but we won't need those more general definitions of convexity here.)</footnote>
and the <m:math overflow="scroll"><m:msub><m:mi>h</m:mi><m:mi>i</m:mi></m:msub></m:math>'s are affine.<footnote id="uid7">I.e., there exists <m:math overflow="scroll"><m:msub><m:mi>a</m:mi><m:mi>i</m:mi></m:msub></m:math>, <m:math overflow="scroll"><m:msub><m:mi>b</m:mi><m:mi>i</m:mi></m:msub></m:math>, so that <m:math overflow="scroll"><m:mrow><m:msub><m:mi>h</m:mi><m:mi>i</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:msubsup><m:mi>a</m:mi><m:mi>i</m:mi><m:mi>T</m:mi></m:msubsup><m:mi>w</m:mi><m:mo>+</m:mo><m:msub><m:mi>b</m:mi><m:mi>i</m:mi></m:msub></m:mrow></m:math>.
“Affine” means the same thing as linear, except that we also allow the extra intercept term <m:math overflow="scroll"><m:msub><m:mi>b</m:mi><m:mi>i</m:mi></m:msub></m:math>.</footnote>
Suppose further that the constraints <m:math overflow="scroll"><m:msub><m:mi>g</m:mi><m:mi>i</m:mi></m:msub></m:math> are (strictly) feasible; this means that there
exists some <m:math overflow="scroll"><m:mi>w</m:mi></m:math> so that <m:math overflow="scroll"><m:mrow><m:msub><m:mi>g</m:mi><m:mi>i</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>)</m:mo></m:mrow><m:mo>&lt;</m:mo><m:mn>0</m:mn></m:mrow></m:math> for all <m:math overflow="scroll"><m:mi>i</m:mi></m:math>.</para>
      <para id="id68971">Under our above assumptions, there must exist <m:math overflow="scroll"><m:mrow><m:msup><m:mi>w</m:mi><m:mo>*</m:mo></m:msup><m:mo>,</m:mo><m:msup><m:mi>α</m:mi><m:mo>*</m:mo></m:msup><m:mo>,</m:mo><m:msup><m:mi>β</m:mi><m:mo>*</m:mo></m:msup></m:mrow></m:math> so that <m:math overflow="scroll"><m:msup><m:mi>w</m:mi><m:mo>*</m:mo></m:msup></m:math> is
the solution to the primal problem, <m:math overflow="scroll"><m:mrow><m:msup><m:mi>α</m:mi><m:mo>*</m:mo></m:msup><m:mo>,</m:mo><m:msup><m:mi>β</m:mi><m:mo>*</m:mo></m:msup></m:mrow></m:math> are the solution to the dual problem, and
moreover <m:math overflow="scroll"><m:mrow><m:msup><m:mi>p</m:mi><m:mo>*</m:mo></m:msup><m:mo>=</m:mo><m:msup><m:mi>d</m:mi><m:mo>*</m:mo></m:msup><m:mo>=</m:mo><m:mi mathvariant="script">L</m:mi><m:mrow><m:mo>(</m:mo><m:msup><m:mi>w</m:mi><m:mo>*</m:mo></m:msup><m:mo>,</m:mo><m:msup><m:mi>α</m:mi><m:mo>*</m:mo></m:msup><m:mo>,</m:mo><m:msup><m:mi>β</m:mi><m:mo>*</m:mo></m:msup><m:mo>)</m:mo></m:mrow></m:mrow></m:math>. Moreover,
<m:math overflow="scroll"><m:mrow><m:msup><m:mi>w</m:mi><m:mo>*</m:mo></m:msup><m:mo>,</m:mo><m:msup><m:mi>α</m:mi><m:mo>*</m:mo></m:msup></m:mrow></m:math> and <m:math overflow="scroll"><m:msup><m:mi>β</m:mi><m:mo>*</m:mo></m:msup></m:math> satisfy the <emphasis effect="bold">Karush-Kuhn-Tucker (KKT) conditions</emphasis>, which are
as follows:
</para>
      <equation id="uid8">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:mfrac>
                    <m:mi>∂</m:mi>
                    <m:mrow>
                      <m:mi>∂</m:mi>
                      <m:msub>
                        <m:mi>w</m:mi>
                        <m:mi>i</m:mi>
                      </m:msub>
                    </m:mrow>
                  </m:mfrac>
                  <m:mi mathvariant="script">L</m:mi>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msup>
                      <m:mi>w</m:mi>
                      <m:mo>*</m:mo>
                    </m:msup>
                    <m:mo>,</m:mo>
                    <m:msup>
                      <m:mi>α</m:mi>
                      <m:mo>*</m:mo>
                    </m:msup>
                    <m:mo>,</m:mo>
                    <m:msup>
                      <m:mi>β</m:mi>
                      <m:mo>*</m:mo>
                    </m:msup>
                    <m:mo>)</m:mo>
                  </m:mrow>
                </m:mrow>
              </m:mtd>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mn>0</m:mn>
                  <m:mo>,</m:mo>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mi>i</m:mi>
                  <m:mo>=</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>,</m:mo>
                  <m:mo>...</m:mo>
                  <m:mo>,</m:mo>
                  <m:mi>n</m:mi>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:mfrac>
                    <m:mi>∂</m:mi>
                    <m:mrow>
                      <m:mi>∂</m:mi>
                      <m:msub>
                        <m:mi>β</m:mi>
                        <m:mi>i</m:mi>
                      </m:msub>
                    </m:mrow>
                  </m:mfrac>
                  <m:mi mathvariant="script">L</m:mi>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msup>
                      <m:mi>w</m:mi>
                      <m:mo>*</m:mo>
                    </m:msup>
                    <m:mo>,</m:mo>
                    <m:msup>
                      <m:mi>α</m:mi>
                      <m:mo>*</m:mo>
                    </m:msup>
                    <m:mo>,</m:mo>
                    <m:msup>
                      <m:mi>β</m:mi>
                      <m:mo>*</m:mo>
                    </m:msup>
                    <m:mo>)</m:mo>
                  </m:mrow>
                </m:mrow>
              </m:mtd>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mn>0</m:mn>
                  <m:mo>,</m:mo>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mi>i</m:mi>
                  <m:mo>=</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>,</m:mo>
                  <m:mo>...</m:mo>
                  <m:mo>,</m:mo>
                  <m:mi>l</m:mi>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:msubsup>
                    <m:mi>α</m:mi>
                    <m:mi>i</m:mi>
                    <m:mo>*</m:mo>
                  </m:msubsup>
                  <m:msub>
                    <m:mi>g</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msup>
                      <m:mi>w</m:mi>
                      <m:mo>*</m:mo>
                    </m:msup>
                    <m:mo>)</m:mo>
                  </m:mrow>
                </m:mrow>
              </m:mtd>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mn>0</m:mn>
                  <m:mo>,</m:mo>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mi>i</m:mi>
                  <m:mo>=</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>,</m:mo>
                  <m:mo>...</m:mo>
                  <m:mo>,</m:mo>
                  <m:mi>k</m:mi>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:msub>
                    <m:mi>g</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msup>
                      <m:mi>w</m:mi>
                      <m:mo>*</m:mo>
                    </m:msup>
                    <m:mo>)</m:mo>
                  </m:mrow>
                </m:mrow>
              </m:mtd>
              <m:mtd>
                <m:mo>≤</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mn>0</m:mn>
                  <m:mo>,</m:mo>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mi>i</m:mi>
                  <m:mo>=</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>,</m:mo>
                  <m:mo>...</m:mo>
                  <m:mo>,</m:mo>
                  <m:mi>k</m:mi>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd columnalign="right">
                <m:msup>
                  <m:mi>α</m:mi>
                  <m:mo>*</m:mo>
                </m:msup>
              </m:mtd>
              <m:mtd>
                <m:mo>≥</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mn>0</m:mn>
                  <m:mo>,</m:mo>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mi>i</m:mi>
                  <m:mo>=</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>,</m:mo>
                  <m:mo>...</m:mo>
                  <m:mo>,</m:mo>
                  <m:mi>k</m:mi>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id69547">Moreover, if some <m:math overflow="scroll"><m:mrow><m:msup><m:mi>w</m:mi><m:mo>*</m:mo></m:msup><m:mo>,</m:mo><m:msup><m:mi>α</m:mi><m:mo>*</m:mo></m:msup><m:mo>,</m:mo><m:msup><m:mi>β</m:mi><m:mo>*</m:mo></m:msup></m:mrow></m:math> satisfy the KKT conditions, then it is also
a solution to the primal and dual problems.</para>
      <para id="id69589">We draw attention to the third equation in <link target-id="uid8"/>, which is called the
KKT <emphasis effect="bold">dual complementarity</emphasis> condition. Specifically, it implies that if
<m:math overflow="scroll"><m:mrow><m:msubsup><m:mi>α</m:mi><m:mi>i</m:mi><m:mo>*</m:mo></m:msubsup><m:mo>&gt;</m:mo><m:mn>0</m:mn></m:mrow></m:math>, then <m:math overflow="scroll"><m:mrow><m:msub><m:mi>g</m:mi><m:mi>i</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:msup><m:mi>w</m:mi><m:mo>*</m:mo></m:msup><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow></m:math>. (I.e., the “<m:math overflow="scroll"><m:mrow><m:msub><m:mi>g</m:mi><m:mi>i</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>)</m:mo></m:mrow><m:mo>≤</m:mo><m:mn>0</m:mn></m:mrow></m:math>”
constraint is <emphasis effect="bold">active</emphasis>, meaning it holds with equality rather
than with inequality.)
Later on, this will be key for showing that the SVM has only a small number of “support vectors”;
the KKT dual complementarity condition will also give us our convergence test when we talk
about the SMO algorithm.</para></section>
    <section id="cid7">
      <title>Optimal margin classifiers</title>
      <para id="id69706">Previously, we posed the following (primal) optimization problem for finding the optimal margin
classifier:</para>
      <equation id="id69710">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:msub>
                  <m:mtext>min</m:mtext>
                  <m:mrow>
                    <m:mi>γ</m:mi>
                    <m:mo>,</m:mo>
                    <m:mi>w</m:mi>
                    <m:mo>,</m:mo>
                    <m:mi>b</m:mi>
                  </m:mrow>
                </m:msub>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mfrac>
                    <m:mn>1</m:mn>
                    <m:mn>2</m:mn>
                  </m:mfrac>
                  <m:msup>
                    <m:mrow>
                      <m:mo>|</m:mo>
                      <m:mo>|</m:mo>
                      <m:mi>w</m:mi>
                      <m:mo>|</m:mo>
                      <m:mo>|</m:mo>
                    </m:mrow>
                    <m:mn>2</m:mn>
                  </m:msup>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mrow>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mtext>s.t.</m:mtext>
                </m:mrow>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:msup>
                    <m:mi>y</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>i</m:mi>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:msup>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msup>
                      <m:mi>w</m:mi>
                      <m:mi>T</m:mi>
                    </m:msup>
                    <m:msup>
                      <m:mi>x</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>i</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msup>
                    <m:mo>+</m:mo>
                    <m:mi>b</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>≥</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>,</m:mo>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mi>i</m:mi>
                  <m:mo>=</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>,</m:mo>
                  <m:mo>...</m:mo>
                  <m:mo>,</m:mo>
                  <m:mi>m</m:mi>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id69876">We can write the constraints as</para>
      <equation id="id69882">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:msub>
              <m:mi>g</m:mi>
              <m:mi>i</m:mi>
            </m:msub>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:mo>-</m:mo>
            <m:msup>
              <m:mi>y</m:mi>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>i</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
            </m:msup>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:msup>
                <m:mi>w</m:mi>
                <m:mi>T</m:mi>
              </m:msup>
              <m:msup>
                <m:mi>x</m:mi>
                <m:mrow>
                  <m:mo>(</m:mo>
                  <m:mi>i</m:mi>
                  <m:mo>)</m:mo>
                </m:mrow>
              </m:msup>
              <m:mo>+</m:mo>
              <m:mi>b</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>+</m:mo>
            <m:mn>1</m:mn>
            <m:mo>≤</m:mo>
            <m:mn>0</m:mn>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id69965">We have one such constraint for each training example. Note that from the KKT dual
complementarity condition, we will have <m:math overflow="scroll"><m:mrow><m:msub><m:mi>α</m:mi><m:mi>i</m:mi></m:msub><m:mo>&gt;</m:mo><m:mn>0</m:mn></m:mrow></m:math> only for the training examples
that have functional margin exactly equal to one (i.e., the ones corresponding
to constraints that hold with equality, <m:math overflow="scroll"><m:mrow><m:msub><m:mi>g</m:mi><m:mi>i</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow></m:math>). Consider the figure below,
in which a maximum margin separating hyperplane is shown by the solid line.</para>
      <figure id="uid9"><media id="uid9_media" alt="the same data set with different parallel lines drawn on it for better fit">
          <image mime-type="image/png" src="../../media/supportVectors.png" id="uid9_onlineimage" width="385"><!-- NOTE: attribute width changes image size online (pixels). original width is 385. --></image>
          <image mime-type="application/postscript" for="pdf" print-width="3.5in" src="../../media/supportVectors.eps" id="uid9_printimage"/>
        </media>
      </figure><para id="id70029">The points with the smallest margins are exactly the ones closest to the decision
boundary; here, these are the three points (one negative and two positive examples)
that lie on the dashed lines parallel to the decision boundary. Thus, only three
of the <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mi>i</m:mi></m:msub></m:math>'s—namely, the ones corresponding to these three training examples—will
be non-zero at the optimal solution to our optimization problem. These three points
are called the <emphasis effect="bold">support vectors</emphasis> in this problem. The fact that the number of
support vectors can be much smaller than the size the training set will be useful later.</para>
      <para id="id70058">Let's move on. Looking ahead, as we develop the dual form of the problem, one key idea
to watch out for is that we'll try to write our algorithm in terms of only the inner product
<m:math overflow="scroll"><m:mrow><m:mo>〈</m:mo><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>,</m:mo><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mi>j</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>〉</m:mo></m:mrow></m:math> (think of this as <m:math overflow="scroll"><m:mrow><m:msup><m:mrow><m:mo>(</m:mo><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>)</m:mo></m:mrow><m:mi>T</m:mi></m:msup><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mi>j</m:mi><m:mo>)</m:mo></m:mrow></m:msup></m:mrow></m:math>)
between points in the input feature space. The fact that we can express our algorithm in
terms of these inner products will be key when we apply the kernel trick.</para>
      <para id="id70150">When we construct the Lagrangian for our optimization problem we have:</para>
      <equation id="uid10">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mi mathvariant="script">L</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>,</m:mo>
              <m:mi>b</m:mi>
              <m:mo>,</m:mo>
              <m:mi>α</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:mfrac>
              <m:mn>1</m:mn>
              <m:mn>2</m:mn>
            </m:mfrac>
            <m:msup>
              <m:mrow>
                <m:mo>|</m:mo>
                <m:mo>|</m:mo>
                <m:mi>w</m:mi>
                <m:mo>|</m:mo>
                <m:mo>|</m:mo>
              </m:mrow>
              <m:mn>2</m:mn>
            </m:msup>
            <m:mo>-</m:mo>
            <m:munderover>
              <m:mo>∑</m:mo>
              <m:mrow>
                <m:mi>i</m:mi>
                <m:mo>=</m:mo>
                <m:mn>1</m:mn>
              </m:mrow>
              <m:mi>m</m:mi>
            </m:munderover>
            <m:msub>
              <m:mi>α</m:mi>
              <m:mi>i</m:mi>
            </m:msub>
            <m:mfenced separators="" open="[" close="]">
              <m:msup>
                <m:mi>y</m:mi>
                <m:mrow>
                  <m:mo>(</m:mo>
                  <m:mi>i</m:mi>
                  <m:mo>)</m:mo>
                </m:mrow>
              </m:msup>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:msup>
                  <m:mi>w</m:mi>
                  <m:mi>T</m:mi>
                </m:msup>
                <m:msup>
                  <m:mi>x</m:mi>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mi>i</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                </m:msup>
                <m:mo>+</m:mo>
                <m:mi>b</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
              <m:mo>-</m:mo>
              <m:mn>1</m:mn>
            </m:mfenced>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id70295">Note that there're only “<m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mi>i</m:mi></m:msub></m:math>” but no “<m:math overflow="scroll"><m:msub><m:mi>β</m:mi><m:mi>i</m:mi></m:msub></m:math>” Lagrange multipliers, since
the problem has only inequality constraints.</para>
      <para id="id70331">Let's find the dual form of the problem. To do so, we need to first minimize <m:math overflow="scroll"><m:mrow><m:mi mathvariant="script">L</m:mi><m:mo>(</m:mo><m:mi>w</m:mi><m:mo>,</m:mo><m:mi>b</m:mi><m:mo>,</m:mo><m:mi>α</m:mi><m:mo>)</m:mo></m:mrow></m:math> with
respect to <m:math overflow="scroll"><m:mi>w</m:mi></m:math> and <m:math overflow="scroll"><m:mi>b</m:mi></m:math> (for fixed <m:math overflow="scroll"><m:mi>α</m:mi></m:math>), to get <m:math overflow="scroll"><m:msub><m:mi>θ</m:mi><m:mi mathvariant="script">D</m:mi></m:msub></m:math>, which we'll do by setting the
derivatives of <m:math overflow="scroll"><m:mi mathvariant="script">L</m:mi></m:math> with respect to <m:math overflow="scroll"><m:mi>w</m:mi></m:math> and <m:math overflow="scroll"><m:mi>b</m:mi></m:math> to zero. We have:</para>
      <equation id="id70435">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:msub>
              <m:mi>∇</m:mi>
              <m:mi>w</m:mi>
            </m:msub>
            <m:mi mathvariant="script">L</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>,</m:mo>
              <m:mi>b</m:mi>
              <m:mo>,</m:mo>
              <m:mi>α</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:mi>w</m:mi>
            <m:mo>-</m:mo>
            <m:munderover>
              <m:mo>∑</m:mo>
              <m:mrow>
                <m:mi>i</m:mi>
                <m:mo>=</m:mo>
                <m:mn>1</m:mn>
              </m:mrow>
              <m:mi>m</m:mi>
            </m:munderover>
            <m:msub>
              <m:mi>α</m:mi>
              <m:mi>i</m:mi>
            </m:msub>
            <m:msup>
              <m:mi>y</m:mi>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>i</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
            </m:msup>
            <m:msup>
              <m:mi>x</m:mi>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>i</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
            </m:msup>
            <m:mo>=</m:mo>
            <m:mn>0</m:mn>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id70532">This implies that</para>
      <equation id="uid11">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mi>w</m:mi>
            <m:mo>=</m:mo>
            <m:munderover>
              <m:mo>∑</m:mo>
              <m:mrow>
                <m:mi>i</m:mi>
                <m:mo>=</m:mo>
                <m:mn>1</m:mn>
              </m:mrow>
              <m:mi>m</m:mi>
            </m:munderover>
            <m:msub>
              <m:mi>α</m:mi>
              <m:mi>i</m:mi>
            </m:msub>
            <m:msup>
              <m:mi>y</m:mi>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>i</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
            </m:msup>
            <m:msup>
              <m:mi>x</m:mi>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>i</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
            </m:msup>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id70608">As for the derivative with respect to <m:math overflow="scroll"><m:mi>b</m:mi></m:math>, we obtain</para>
      <equation id="uid12">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mfrac>
              <m:mi>∂</m:mi>
              <m:mrow>
                <m:mi>∂</m:mi>
                <m:mi>b</m:mi>
              </m:mrow>
            </m:mfrac>
            <m:mi mathvariant="script">L</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>,</m:mo>
              <m:mi>b</m:mi>
              <m:mo>,</m:mo>
              <m:mi>α</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:munderover>
              <m:mo>∑</m:mo>
              <m:mrow>
                <m:mi>i</m:mi>
                <m:mo>=</m:mo>
                <m:mn>1</m:mn>
              </m:mrow>
              <m:mi>m</m:mi>
            </m:munderover>
            <m:msub>
              <m:mi>α</m:mi>
              <m:mi>i</m:mi>
            </m:msub>
            <m:msup>
              <m:mi>y</m:mi>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>i</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
            </m:msup>
            <m:mo>=</m:mo>
            <m:mn>0</m:mn>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id70713">If we take the definition of <m:math overflow="scroll"><m:mi>w</m:mi></m:math> in Equation <link target-id="uid11"/> and plug that back into
the Lagrangian (Equation <link target-id="uid10"/>), and simplify, we get</para>
      <equation id="id70736">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mi mathvariant="script">L</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>,</m:mo>
              <m:mi>b</m:mi>
              <m:mo>,</m:mo>
              <m:mi>α</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:munderover>
              <m:mo>∑</m:mo>
              <m:mrow>
                <m:mi>i</m:mi>
                <m:mo>=</m:mo>
                <m:mn>1</m:mn>
              </m:mrow>
              <m:mi>m</m:mi>
            </m:munderover>
            <m:msub>
              <m:mi>α</m:mi>
              <m:mi>i</m:mi>
            </m:msub>
            <m:mo>-</m:mo>
            <m:mfrac>
              <m:mn>1</m:mn>
              <m:mn>2</m:mn>
            </m:mfrac>
            <m:munderover>
              <m:mo>∑</m:mo>
              <m:mrow>
                <m:mi>i</m:mi>
                <m:mo>,</m:mo>
                <m:mi>j</m:mi>
                <m:mo>=</m:mo>
                <m:mn>1</m:mn>
              </m:mrow>
              <m:mi>m</m:mi>
            </m:munderover>
            <m:msup>
              <m:mi>y</m:mi>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>i</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
            </m:msup>
            <m:msup>
              <m:mi>y</m:mi>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>j</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
            </m:msup>
            <m:msub>
              <m:mi>α</m:mi>
              <m:mi>i</m:mi>
            </m:msub>
            <m:msub>
              <m:mi>α</m:mi>
              <m:mi>j</m:mi>
            </m:msub>
            <m:msup>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:msup>
                  <m:mi>x</m:mi>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mi>i</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                </m:msup>
                <m:mo>)</m:mo>
              </m:mrow>
              <m:mi>T</m:mi>
            </m:msup>
            <m:msup>
              <m:mi>x</m:mi>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>j</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
            </m:msup>
            <m:mo>-</m:mo>
            <m:mi>b</m:mi>
            <m:munderover>
              <m:mo>∑</m:mo>
              <m:mrow>
                <m:mi>i</m:mi>
                <m:mo>=</m:mo>
                <m:mn>1</m:mn>
              </m:mrow>
              <m:mi>m</m:mi>
            </m:munderover>
            <m:msub>
              <m:mi>α</m:mi>
              <m:mi>i</m:mi>
            </m:msub>
            <m:msup>
              <m:mi>y</m:mi>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>i</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
            </m:msup>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id70942">But from Equation <link target-id="uid12"/>, the last term must be zero, so we obtain</para>
      <equation id="id70953">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mi mathvariant="script">L</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>,</m:mo>
              <m:mi>b</m:mi>
              <m:mo>,</m:mo>
              <m:mi>α</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:munderover>
              <m:mo>∑</m:mo>
              <m:mrow>
                <m:mi>i</m:mi>
                <m:mo>=</m:mo>
                <m:mn>1</m:mn>
              </m:mrow>
              <m:mi>m</m:mi>
            </m:munderover>
            <m:msub>
              <m:mi>α</m:mi>
              <m:mi>i</m:mi>
            </m:msub>
            <m:mo>-</m:mo>
            <m:mfrac>
              <m:mn>1</m:mn>
              <m:mn>2</m:mn>
            </m:mfrac>
            <m:munderover>
              <m:mo>∑</m:mo>
              <m:mrow>
                <m:mi>i</m:mi>
                <m:mo>,</m:mo>
                <m:mi>j</m:mi>
                <m:mo>=</m:mo>
                <m:mn>1</m:mn>
              </m:mrow>
              <m:mi>m</m:mi>
            </m:munderover>
            <m:msup>
              <m:mi>y</m:mi>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>i</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
            </m:msup>
            <m:msup>
              <m:mi>y</m:mi>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>j</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
            </m:msup>
            <m:msub>
              <m:mi>α</m:mi>
              <m:mi>i</m:mi>
            </m:msub>
            <m:msub>
              <m:mi>α</m:mi>
              <m:mi>j</m:mi>
            </m:msub>
            <m:msup>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:msup>
                  <m:mi>x</m:mi>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mi>i</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                </m:msup>
                <m:mo>)</m:mo>
              </m:mrow>
              <m:mi>T</m:mi>
            </m:msup>
            <m:msup>
              <m:mi>x</m:mi>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>j</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
            </m:msup>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id71118">Recall that we got to the equation above by minimizing <m:math overflow="scroll"><m:mi mathvariant="script">L</m:mi></m:math> with respect to <m:math overflow="scroll"><m:mi>w</m:mi></m:math> and <m:math overflow="scroll"><m:mi>b</m:mi></m:math>.
Putting this together with the constraints <m:math overflow="scroll"><m:mrow><m:msub><m:mi>α</m:mi><m:mi>i</m:mi></m:msub><m:mo>≥</m:mo><m:mn>0</m:mn></m:mrow></m:math> (that we always had) and the
constraint <link target-id="uid12"/>, we obtain the following dual optimization problem:</para>
      <equation id="id71178">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:msub>
                  <m:mtext>max</m:mtext>
                  <m:mi>α</m:mi>
                </m:msub>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mi>W</m:mi>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mi>α</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>=</m:mo>
                  <m:munderover>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:mi>i</m:mi>
                      <m:mo>=</m:mo>
                      <m:mn>1</m:mn>
                    </m:mrow>
                    <m:mi>m</m:mi>
                  </m:munderover>
                  <m:msub>
                    <m:mi>α</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:mo>-</m:mo>
                  <m:mfrac>
                    <m:mn>1</m:mn>
                    <m:mn>2</m:mn>
                  </m:mfrac>
                  <m:munderover>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:mi>i</m:mi>
                      <m:mo>,</m:mo>
                      <m:mi>j</m:mi>
                      <m:mo>=</m:mo>
                      <m:mn>1</m:mn>
                    </m:mrow>
                    <m:mi>m</m:mi>
                  </m:munderover>
                  <m:msup>
                    <m:mi>y</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>i</m:mi>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:msup>
                  <m:msup>
                    <m:mi>y</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>j</m:mi>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:msup>
                  <m:msub>
                    <m:mi>α</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:msub>
                    <m:mi>α</m:mi>
                    <m:mi>j</m:mi>
                  </m:msub>
                  <m:mrow>
                    <m:mo>〈</m:mo>
                    <m:msup>
                      <m:mi>x</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>i</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msup>
                    <m:mo>,</m:mo>
                    <m:msup>
                      <m:mi>x</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>j</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msup>
                    <m:mo>〉</m:mo>
                  </m:mrow>
                  <m:mo>.</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mrow>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mtext>s.t.</m:mtext>
                </m:mrow>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:msub>
                    <m:mi>α</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:mo>≥</m:mo>
                  <m:mn>0</m:mn>
                  <m:mo>,</m:mo>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mi>i</m:mi>
                  <m:mo>=</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>,</m:mo>
                  <m:mo>...</m:mo>
                  <m:mo>,</m:mo>
                  <m:mi>m</m:mi>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd/>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:munderover>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:mi>i</m:mi>
                      <m:mo>=</m:mo>
                      <m:mn>1</m:mn>
                    </m:mrow>
                    <m:mi>m</m:mi>
                  </m:munderover>
                  <m:msub>
                    <m:mi>α</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:msup>
                    <m:mi>y</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>i</m:mi>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:msup>
                  <m:mo>=</m:mo>
                  <m:mn>0</m:mn>
                  <m:mo>,</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id71458">You should also be able to verify that the conditions required for <m:math overflow="scroll"><m:mrow><m:msup><m:mi>p</m:mi><m:mo>*</m:mo></m:msup><m:mo>=</m:mo><m:msup><m:mi>d</m:mi><m:mo>*</m:mo></m:msup></m:mrow></m:math> and the KKT conditions
(<link target-id="uid8"/>) to hold are indeed satisfied in our optimization
problem. Hence, we can solve the dual in lieu of solving the primal problem. Specifically, in the dual problem
above, we have a maximization problem in which the parameters are the <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mi>i</m:mi></m:msub></m:math>'s. We'll talk later
about the specific algorithm that we're going to use to solve the dual problem, but if we are
indeed able to solve it (i.e., find the <m:math overflow="scroll"><m:mi>α</m:mi></m:math>'s that maximize <m:math overflow="scroll"><m:mrow><m:mi>W</m:mi><m:mo>(</m:mo><m:mi>α</m:mi><m:mo>)</m:mo></m:mrow></m:math> subject to the
constraints), then we can use Equation <link target-id="uid11"/> to go back and find the optimal <m:math overflow="scroll"><m:mi>w</m:mi></m:math>'s
as a function of the <m:math overflow="scroll"><m:mi>α</m:mi></m:math>'s. Having found <m:math overflow="scroll"><m:msup><m:mi>w</m:mi><m:mo>*</m:mo></m:msup></m:math>,
by considering the primal problem, it is also straightforward to find the optimal value for
the intercept term <m:math overflow="scroll"><m:mi>b</m:mi></m:math> as</para><equation id="uid13">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:msup>
              <m:mi>b</m:mi>
              <m:mo>*</m:mo>
            </m:msup>
            <m:mo>=</m:mo>
            <m:mo>-</m:mo>
            <m:mfrac>
              <m:mrow>
                <m:msub>
                  <m:mo movablelimits="true" form="prefix">max</m:mo>
                  <m:mrow>
                    <m:mi>i</m:mi>
                    <m:mo>:</m:mo>
                    <m:msup>
                      <m:mi>y</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>i</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msup>
                    <m:mo>=</m:mo>
                    <m:mo>-</m:mo>
                    <m:mn>1</m:mn>
                  </m:mrow>
                </m:msub>
                <m:msup>
                  <m:mrow>
                    <m:msup>
                      <m:mi>w</m:mi>
                      <m:mo>*</m:mo>
                    </m:msup>
                  </m:mrow>
                  <m:mi>T</m:mi>
                </m:msup>
                <m:msup>
                  <m:mi>x</m:mi>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mi>i</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                </m:msup>
                <m:mo>+</m:mo>
                <m:msub>
                  <m:mo movablelimits="true" form="prefix">min</m:mo>
                  <m:mrow>
                    <m:mi>i</m:mi>
                    <m:mo>:</m:mo>
                    <m:msup>
                      <m:mi>y</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>i</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msup>
                    <m:mo>=</m:mo>
                    <m:mn>1</m:mn>
                  </m:mrow>
                </m:msub>
                <m:msup>
                  <m:mrow>
                    <m:msup>
                      <m:mi>w</m:mi>
                      <m:mo>*</m:mo>
                    </m:msup>
                  </m:mrow>
                  <m:mi>T</m:mi>
                </m:msup>
                <m:msup>
                  <m:mi>x</m:mi>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mi>i</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                </m:msup>
              </m:mrow>
              <m:mn>2</m:mn>
            </m:mfrac>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id71742">(Check for yourself that this is correct.)</para>
      <para id="id71748">Before moving on, let's also take a more careful look at Equation <link target-id="uid11"/>, which gives
the optimal value of <m:math overflow="scroll"><m:mi>w</m:mi></m:math> in terms of (the optimal value of) <m:math overflow="scroll"><m:mi>α</m:mi></m:math>. Suppose we've fit our
model's parameters
to a training set, and now wish to make a prediction at a new point input <m:math overflow="scroll"><m:mi>x</m:mi></m:math>. We would then
calculate <m:math overflow="scroll"><m:mrow><m:msup><m:mi>w</m:mi><m:mi>T</m:mi></m:msup><m:mi>x</m:mi><m:mo>+</m:mo><m:mi>b</m:mi></m:mrow></m:math>, and predict <m:math overflow="scroll"><m:mrow><m:mi>y</m:mi><m:mo>=</m:mo><m:mn>1</m:mn></m:mrow></m:math> if and only if this quantity is bigger than zero. But
using <link target-id="uid11"/>, this quantity can also be written:</para>
      <equation id="uid14">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:msup>
                    <m:mi>w</m:mi>
                    <m:mi>T</m:mi>
                  </m:msup>
                  <m:mi>x</m:mi>
                  <m:mo>+</m:mo>
                  <m:mi>b</m:mi>
                </m:mrow>
              </m:mtd>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:msup>
                    <m:mfenced separators="" open="(" close=")">
                      <m:munderover>
                        <m:mo>∑</m:mo>
                        <m:mrow>
                          <m:mi>i</m:mi>
                          <m:mo>=</m:mo>
                          <m:mn>1</m:mn>
                        </m:mrow>
                        <m:mi>m</m:mi>
                      </m:munderover>
                      <m:msub>
                        <m:mi>α</m:mi>
                        <m:mi>i</m:mi>
                      </m:msub>
                      <m:msup>
                        <m:mi>y</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:mi>i</m:mi>
                          <m:mo>)</m:mo>
                        </m:mrow>
                      </m:msup>
                      <m:msup>
                        <m:mi>x</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:mi>i</m:mi>
                          <m:mo>)</m:mo>
                        </m:mrow>
                      </m:msup>
                    </m:mfenced>
                    <m:mi>T</m:mi>
                  </m:msup>
                  <m:mi>x</m:mi>
                  <m:mo>+</m:mo>
                  <m:mi>b</m:mi>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:munderover>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:mi>i</m:mi>
                      <m:mo>=</m:mo>
                      <m:mn>1</m:mn>
                    </m:mrow>
                    <m:mi>m</m:mi>
                  </m:munderover>
                  <m:msub>
                    <m:mi>α</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:msup>
                    <m:mi>y</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>i</m:mi>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:msup>
                  <m:mrow>
                    <m:mo>〈</m:mo>
                    <m:msup>
                      <m:mi>x</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>i</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msup>
                    <m:mo>,</m:mo>
                    <m:mi>x</m:mi>
                    <m:mo>〉</m:mo>
                  </m:mrow>
                  <m:mo>+</m:mo>
                  <m:mi>b</m:mi>
                  <m:mo>.</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id72014">Hence, if we've found the <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mi>i</m:mi></m:msub></m:math>'s, in order to make a prediction, we have to calculate
a quantity that depends only on the inner product between <m:math overflow="scroll"><m:mi>x</m:mi></m:math> and the points in
the training set. Moreover, we saw earlier that the <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mi>i</m:mi></m:msub></m:math>'s will all be zero except
for the support vectors. Thus, many of the terms in the sum above will be zero, and we
really need to find only the inner products between <m:math overflow="scroll"><m:mi>x</m:mi></m:math> and the support vectors (of
which there is often only a small number) in order calculate <link target-id="uid14"/> and make our prediction.</para>
      <para id="id72076">By examining the dual form of the optimization problem,
we gained significant insight into the structure of the problem,
and were also able to write the entire algorithm in terms of only inner products between
input feature vectors. In the next section, we will exploit this property to
apply the kernels to our classification problem. The resulting algorithm, <emphasis effect="bold">support vector machines</emphasis>,
will be able to efficiently learn in very high dimensional spaces.</para>
    </section>
    <section id="cid8">
      <title>Kernels</title>
      <para id="id72098">Back in our discussion of linear regression, we had a problem
in which the input <m:math overflow="scroll"><m:mi>x</m:mi></m:math> was the living area of a house, and we considered
performing regression using the features <m:math overflow="scroll"><m:mi>x</m:mi></m:math>, <m:math overflow="scroll"><m:msup><m:mi>x</m:mi><m:mn>2</m:mn></m:msup></m:math> and <m:math overflow="scroll"><m:msup><m:mi>x</m:mi><m:mn>3</m:mn></m:msup></m:math> (say) to obtain
a cubic function. To distinguish between these two sets of variables, we'll
call the “original” input value the input <emphasis effect="bold">attributes</emphasis> of a problem
(in this case, <m:math overflow="scroll"><m:mi>x</m:mi></m:math>, the living area). When that is mapped to some new set of
quantities that are then passed to the learning algorithm, we'll call those
new quantities the input <emphasis effect="bold">features</emphasis>. (Unfortunately, different authors
use different terms to describe these two things, but we'll try to use this
terminology consistently in these notes.) We will also let <m:math overflow="scroll"><m:mi>Φ</m:mi></m:math> denote
the <emphasis effect="bold">feature mapping</emphasis>, which maps from the attributes to the features.
For instance, in our example, we had</para>
      <equation id="id72189">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mi>Φ</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>x</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:mfenced separators="" open="[" close="]">
              <m:mtable>
                <m:mtr>
                  <m:mtd>
                    <m:mi>x</m:mi>
                  </m:mtd>
                </m:mtr>
                <m:mtr>
                  <m:mtd>
                    <m:msup>
                      <m:mi>x</m:mi>
                      <m:mn>2</m:mn>
                    </m:msup>
                  </m:mtd>
                </m:mtr>
                <m:mtr>
                  <m:mtd>
                    <m:msup>
                      <m:mi>x</m:mi>
                      <m:mn>3</m:mn>
                    </m:msup>
                  </m:mtd>
                </m:mtr>
              </m:mtable>
            </m:mfenced>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id72245">Rather than applying SVMs using the original input attributes <m:math overflow="scroll"><m:mi>x</m:mi></m:math>, we may instead
want to learn using some features <m:math overflow="scroll"><m:mrow><m:mi>Φ</m:mi><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow></m:math>. To do so,
we simply need to go over our previous algorithm, and replace <m:math overflow="scroll"><m:mi>x</m:mi></m:math> everywhere in
it with <m:math overflow="scroll"><m:mrow><m:mi>Φ</m:mi><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow></m:math>.</para>
      <para id="id72301">Since the algorithm can be written entirely in terms of the inner products
<m:math overflow="scroll"><m:mrow><m:mo>〈</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>〉</m:mo></m:mrow></m:math>, this means that we would replace all those inner products
with <m:math overflow="scroll"><m:mrow><m:mo>〈</m:mo><m:mi>Φ</m:mi><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo><m:mo>,</m:mo><m:mi>Φ</m:mi><m:mo>(</m:mo><m:mi>z</m:mi><m:mo>)</m:mo><m:mo>〉</m:mo></m:mrow></m:math>. Specificically, given a feature mapping
<m:math overflow="scroll"><m:mi>Φ</m:mi></m:math>, we define the corresponding <emphasis effect="bold">Kernel</emphasis> to be</para>
      <equation id="id72371">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mi>K</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>x</m:mi>
              <m:mo>,</m:mo>
              <m:mi>z</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:mi>Φ</m:mi>
            <m:msup>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>x</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
              <m:mi>T</m:mi>
            </m:msup>
            <m:mi>Φ</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>z</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id72424">Then, everywhere we previously had
<m:math overflow="scroll"><m:mrow><m:mo>〈</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>〉</m:mo></m:mrow></m:math> in our algorithm, we could simply replace
it with <m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow></m:math>, and our algorithm would now be learning using the features <m:math overflow="scroll"><m:mi>Φ</m:mi></m:math>.</para>
      <para id="id72479">Now, given <m:math overflow="scroll"><m:mi>Φ</m:mi></m:math>, we could easily compute <m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow></m:math> by finding <m:math overflow="scroll"><m:mrow><m:mi>Φ</m:mi><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow></m:math> and <m:math overflow="scroll"><m:mrow><m:mi>Φ</m:mi><m:mo>(</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow></m:math>
and taking their inner product. But what's more
interesting is that often, <m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow></m:math> may be very inexpensive to calculate, even
though <m:math overflow="scroll"><m:mrow><m:mi>Φ</m:mi><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow></m:math> itself may be very expensive to calculate (perhaps because it is
an extremely high dimensional vector). In such settings, by using in our algorithm
an efficient way to calculate <m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow></m:math>, we can get SVMs to learn in
the high dimensional feature space space given by <m:math overflow="scroll"><m:mi>Φ</m:mi></m:math>, but without ever having
to explicitly find or represent vectors <m:math overflow="scroll"><m:mrow><m:mi>Φ</m:mi><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow></m:math>.</para>
      <para id="id72632">Let's see an example. Suppose <m:math overflow="scroll"><m:mrow><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>∈</m:mo><m:msup><m:mrow><m:mi mathvariant="double-struck">R</m:mi></m:mrow><m:mi>n</m:mi></m:msup></m:mrow></m:math>, and consider</para>
      <equation id="id72662">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mi>K</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>x</m:mi>
              <m:mo>,</m:mo>
              <m:mi>z</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:msup>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:msup>
                  <m:mi>x</m:mi>
                  <m:mi>T</m:mi>
                </m:msup>
                <m:mi>z</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
              <m:mn>2</m:mn>
            </m:msup>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id72711">We can also write this as</para>
      <equation id="id72717">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:mi>K</m:mi>
                  <m:mo>(</m:mo>
                  <m:mi>x</m:mi>
                  <m:mo>,</m:mo>
                  <m:mi>z</m:mi>
                  <m:mo>)</m:mo>
                </m:mrow>
              </m:mtd>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mfenced separators="" open="(" close=")">
                    <m:munderover>
                      <m:mo>∑</m:mo>
                      <m:mrow>
                        <m:mi>i</m:mi>
                        <m:mo>=</m:mo>
                        <m:mn>1</m:mn>
                      </m:mrow>
                      <m:mi>n</m:mi>
                    </m:munderover>
                    <m:msub>
                      <m:mi>x</m:mi>
                      <m:mi>i</m:mi>
                    </m:msub>
                    <m:msub>
                      <m:mi>z</m:mi>
                      <m:mi>i</m:mi>
                    </m:msub>
                  </m:mfenced>
                  <m:mfenced separators="" open="(" close=")">
                    <m:munderover>
                      <m:mo>∑</m:mo>
                      <m:mrow>
                        <m:mi>j</m:mi>
                        <m:mo>=</m:mo>
                        <m:mn>1</m:mn>
                      </m:mrow>
                      <m:mi>n</m:mi>
                    </m:munderover>
                    <m:msub>
                      <m:mi>x</m:mi>
                      <m:mi>i</m:mi>
                    </m:msub>
                    <m:msub>
                      <m:mi>z</m:mi>
                      <m:mi>i</m:mi>
                    </m:msub>
                  </m:mfenced>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:munderover>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:mi>i</m:mi>
                      <m:mo>=</m:mo>
                      <m:mn>1</m:mn>
                    </m:mrow>
                    <m:mi>n</m:mi>
                  </m:munderover>
                  <m:munderover>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:mi>j</m:mi>
                      <m:mo>=</m:mo>
                      <m:mn>1</m:mn>
                    </m:mrow>
                    <m:mi>n</m:mi>
                  </m:munderover>
                  <m:msub>
                    <m:mi>x</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:msub>
                    <m:mi>x</m:mi>
                    <m:mi>j</m:mi>
                  </m:msub>
                  <m:msub>
                    <m:mi>z</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:msub>
                    <m:mi>z</m:mi>
                    <m:mi>j</m:mi>
                  </m:msub>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:munderover>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:mi>i</m:mi>
                      <m:mo>,</m:mo>
                      <m:mi>j</m:mi>
                      <m:mo>=</m:mo>
                      <m:mn>1</m:mn>
                    </m:mrow>
                    <m:mi>n</m:mi>
                  </m:munderover>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msub>
                      <m:mi>x</m:mi>
                      <m:mi>i</m:mi>
                    </m:msub>
                    <m:msub>
                      <m:mi>x</m:mi>
                      <m:mi>j</m:mi>
                    </m:msub>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msub>
                      <m:mi>z</m:mi>
                      <m:mi>i</m:mi>
                    </m:msub>
                    <m:msub>
                      <m:mi>z</m:mi>
                      <m:mi>j</m:mi>
                    </m:msub>
                    <m:mo>)</m:mo>
                  </m:mrow>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id72974">Thus, we see that <m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mi>Φ</m:mi><m:msup><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow><m:mi>T</m:mi></m:msup><m:mi>Φ</m:mi><m:mrow><m:mo>(</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:math>, where the feature mapping <m:math overflow="scroll"><m:mi>Φ</m:mi></m:math>
is given (shown here for the case of <m:math overflow="scroll"><m:mrow><m:mi>n</m:mi><m:mo>=</m:mo><m:mn>3</m:mn></m:mrow></m:math>) by</para>
      <equation id="id73052">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mi>Φ</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>x</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:mfenced separators="" open="[" close="]">
              <m:mtable>
                <m:mtr>
                  <m:mtd>
                    <m:mrow>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>1</m:mn>
                      </m:msub>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>1</m:mn>
                      </m:msub>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>
                <m:mtr>
                  <m:mtd>
                    <m:mrow>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>1</m:mn>
                      </m:msub>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>2</m:mn>
                      </m:msub>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>
                <m:mtr>
                  <m:mtd>
                    <m:mrow>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>1</m:mn>
                      </m:msub>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>3</m:mn>
                      </m:msub>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>
                <m:mtr>
                  <m:mtd>
                    <m:mrow>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>2</m:mn>
                      </m:msub>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>1</m:mn>
                      </m:msub>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>
                <m:mtr>
                  <m:mtd>
                    <m:mrow>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>2</m:mn>
                      </m:msub>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>2</m:mn>
                      </m:msub>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>
                <m:mtr>
                  <m:mtd>
                    <m:mrow>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>2</m:mn>
                      </m:msub>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>3</m:mn>
                      </m:msub>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>
                <m:mtr>
                  <m:mtd>
                    <m:mrow>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>3</m:mn>
                      </m:msub>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>1</m:mn>
                      </m:msub>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>
                <m:mtr>
                  <m:mtd>
                    <m:mrow>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>3</m:mn>
                      </m:msub>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>2</m:mn>
                      </m:msub>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>
                <m:mtr>
                  <m:mtd>
                    <m:mrow>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>3</m:mn>
                      </m:msub>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>3</m:mn>
                      </m:msub>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>
              </m:mtable>
            </m:mfenced>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id73247">Note that whereas calculating the high-dimensional <m:math overflow="scroll"><m:mrow><m:mi>Φ</m:mi><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow></m:math> requires <m:math overflow="scroll"><m:mrow><m:mi>O</m:mi><m:mo>(</m:mo><m:msup><m:mi>n</m:mi><m:mn>2</m:mn></m:msup><m:mo>)</m:mo></m:mrow></m:math> time,
finding <m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow></m:math> takes only <m:math overflow="scroll"><m:mrow><m:mi>O</m:mi><m:mo>(</m:mo><m:mi>n</m:mi><m:mo>)</m:mo></m:mrow></m:math> time—linear in the dimension of the input attributes.</para>
      <para id="id73330">For a related kernel, also consider</para>
      <equation id="id73334">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:mi>K</m:mi>
                  <m:mo>(</m:mo>
                  <m:mi>x</m:mi>
                  <m:mo>,</m:mo>
                  <m:mi>z</m:mi>
                  <m:mo>)</m:mo>
                </m:mrow>
              </m:mtd>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:msup>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msup>
                      <m:mi>x</m:mi>
                      <m:mi>T</m:mi>
                    </m:msup>
                    <m:mi>z</m:mi>
                    <m:mo>+</m:mo>
                    <m:mi>c</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mn>2</m:mn>
                </m:msup>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:munderover>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:mi>i</m:mi>
                      <m:mo>,</m:mo>
                      <m:mi>j</m:mi>
                      <m:mo>=</m:mo>
                      <m:mn>1</m:mn>
                    </m:mrow>
                    <m:mi>n</m:mi>
                  </m:munderover>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msub>
                      <m:mi>x</m:mi>
                      <m:mi>i</m:mi>
                    </m:msub>
                    <m:msub>
                      <m:mi>x</m:mi>
                      <m:mi>j</m:mi>
                    </m:msub>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msub>
                      <m:mi>z</m:mi>
                      <m:mi>i</m:mi>
                    </m:msub>
                    <m:msub>
                      <m:mi>z</m:mi>
                      <m:mi>j</m:mi>
                    </m:msub>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>+</m:mo>
                  <m:munderover>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:mi>i</m:mi>
                      <m:mo>=</m:mo>
                      <m:mn>1</m:mn>
                    </m:mrow>
                    <m:mi>n</m:mi>
                  </m:munderover>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msqrt>
                      <m:mrow>
                        <m:mn>2</m:mn>
                        <m:mi>c</m:mi>
                      </m:mrow>
                    </m:msqrt>
                    <m:msub>
                      <m:mi>x</m:mi>
                      <m:mi>i</m:mi>
                    </m:msub>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msqrt>
                      <m:mrow>
                        <m:mn>2</m:mn>
                        <m:mi>c</m:mi>
                      </m:mrow>
                    </m:msqrt>
                    <m:msub>
                      <m:mi>z</m:mi>
                      <m:mi>i</m:mi>
                    </m:msub>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>+</m:mo>
                  <m:msup>
                    <m:mi>c</m:mi>
                    <m:mn>2</m:mn>
                  </m:msup>
                  <m:mo>.</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id73533">(Check this yourself.) This corresponds to the feature mapping (again shown for <m:math overflow="scroll"><m:mrow><m:mi>n</m:mi><m:mo>=</m:mo><m:mn>3</m:mn></m:mrow></m:math>)</para>
      <equation id="id73554">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mi>Φ</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>x</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:mfenced separators="" open="[" close="]">
              <m:mtable>
                <m:mtr>
                  <m:mtd>
                    <m:mrow>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>1</m:mn>
                      </m:msub>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>1</m:mn>
                      </m:msub>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>
                <m:mtr>
                  <m:mtd>
                    <m:mrow>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>1</m:mn>
                      </m:msub>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>2</m:mn>
                      </m:msub>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>
                <m:mtr>
                  <m:mtd>
                    <m:mrow>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>1</m:mn>
                      </m:msub>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>3</m:mn>
                      </m:msub>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>
                <m:mtr>
                  <m:mtd>
                    <m:mrow>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>2</m:mn>
                      </m:msub>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>1</m:mn>
                      </m:msub>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>
                <m:mtr>
                  <m:mtd>
                    <m:mrow>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>2</m:mn>
                      </m:msub>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>2</m:mn>
                      </m:msub>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>
                <m:mtr>
                  <m:mtd>
                    <m:mrow>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>2</m:mn>
                      </m:msub>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>3</m:mn>
                      </m:msub>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>
                <m:mtr>
                  <m:mtd>
                    <m:mrow>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>3</m:mn>
                      </m:msub>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>1</m:mn>
                      </m:msub>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>
                <m:mtr>
                  <m:mtd>
                    <m:mrow>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>3</m:mn>
                      </m:msub>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>2</m:mn>
                      </m:msub>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>
                <m:mtr>
                  <m:mtd>
                    <m:mrow>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>3</m:mn>
                      </m:msub>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>3</m:mn>
                      </m:msub>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>
                <m:mtr>
                  <m:mtd>
                    <m:mrow>
                      <m:msqrt>
                        <m:mrow>
                          <m:mn>2</m:mn>
                          <m:mi>c</m:mi>
                        </m:mrow>
                      </m:msqrt>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>1</m:mn>
                      </m:msub>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>
                <m:mtr>
                  <m:mtd>
                    <m:mrow>
                      <m:msqrt>
                        <m:mrow>
                          <m:mn>2</m:mn>
                          <m:mi>c</m:mi>
                        </m:mrow>
                      </m:msqrt>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>2</m:mn>
                      </m:msub>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>
                <m:mtr>
                  <m:mtd>
                    <m:mrow>
                      <m:msqrt>
                        <m:mrow>
                          <m:mn>2</m:mn>
                          <m:mi>c</m:mi>
                        </m:mrow>
                      </m:msqrt>
                      <m:msub>
                        <m:mi>x</m:mi>
                        <m:mn>3</m:mn>
                      </m:msub>
                    </m:mrow>
                  </m:mtd>
                </m:mtr>
                <m:mtr>
                  <m:mtd>
                    <m:mi>c</m:mi>
                  </m:mtd>
                </m:mtr>
              </m:mtable>
            </m:mfenced>
            <m:mo>,</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id73804">and the parameter <m:math overflow="scroll"><m:mi>c</m:mi></m:math> controls the relative weighting between the <m:math overflow="scroll"><m:msub><m:mi>x</m:mi><m:mi>i</m:mi></m:msub></m:math> (first order) and the
<m:math overflow="scroll"><m:mrow><m:msub><m:mi>x</m:mi><m:mi>i</m:mi></m:msub><m:msub><m:mi>x</m:mi><m:mi>j</m:mi></m:msub></m:mrow></m:math> (second order) terms.</para>
      <para id="id73856">More broadly, the kernel <m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:msup><m:mrow><m:mo>(</m:mo><m:msup><m:mi>x</m:mi><m:mi>T</m:mi></m:msup><m:mi>z</m:mi><m:mo>+</m:mo><m:mi>c</m:mi><m:mo>)</m:mo></m:mrow><m:mi>d</m:mi></m:msup></m:mrow></m:math> corresponds to a feature mapping
to an 
<m:math overflow="scroll">
 <m:mfenced separators="" open="(" close=")">    
  <m:msubsup>
<m:mrow/>
   <m:mrow>
<m:mspace width=".90em"/>
    <m:mi>d</m:mi>
   </m:mrow>
     <m:mrow>
      <m:mi>n</m:mi>
      <m:mo>+</m:mo>
      <m:mi>d</m:mi>
     </m:mrow>

  </m:msubsup>
 </m:mfenced>
</m:math> feature space, corresponding
of all monomials of the form <m:math overflow="scroll"><m:mrow><m:msub><m:mi>x</m:mi><m:msub><m:mi>i</m:mi><m:mn>1</m:mn></m:msub></m:msub><m:msub><m:mi>x</m:mi><m:msub><m:mi>i</m:mi><m:mn>2</m:mn></m:msub></m:msub><m:mo>...</m:mo><m:msub><m:mi>x</m:mi><m:msub><m:mi>i</m:mi><m:mi>k</m:mi></m:msub></m:msub></m:mrow></m:math> that are up to order <m:math overflow="scroll"><m:mi>d</m:mi></m:math>. However, despite
working in this <m:math overflow="scroll"><m:mrow><m:mi>O</m:mi><m:mo>(</m:mo><m:msup><m:mi>n</m:mi><m:mi>d</m:mi></m:msup><m:mo>)</m:mo></m:mrow></m:math>-dimensional space, computing <m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow></m:math> still takes only <m:math overflow="scroll"><m:mrow><m:mi>O</m:mi><m:mo>(</m:mo><m:mi>n</m:mi><m:mo>)</m:mo></m:mrow></m:math> time,
and hence we never need to explicitly represent feature vectors in this very high dimensional
feature space.</para><para id="id74105">Now, let's talk about a slightly different view of kernels. Intuitively,
(and there are things wrong with this intuition, but nevermind),
if <m:math overflow="scroll"><m:mrow><m:mi>Φ</m:mi><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow></m:math>
and <m:math overflow="scroll"><m:mrow><m:mi>Φ</m:mi><m:mo>(</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow></m:math> are close together, then we might expect <m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mi>Φ</m:mi><m:msup><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow><m:mi>T</m:mi></m:msup><m:mi>Φ</m:mi><m:mrow><m:mo>(</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:math> to be
large. Conversely, if <m:math overflow="scroll"><m:mrow><m:mi>Φ</m:mi><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow></m:math> and <m:math overflow="scroll"><m:mrow><m:mi>Φ</m:mi><m:mo>(</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow></m:math> are far apart—say nearly orthogonal to
each other—then <m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mi>Φ</m:mi><m:msup><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow><m:mi>T</m:mi></m:msup><m:mi>Φ</m:mi><m:mrow><m:mo>(</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:math> will be small. So, we can think
of <m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow></m:math> as some measurement of how similar are <m:math overflow="scroll"><m:mrow><m:mi>Φ</m:mi><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow></m:math> and <m:math overflow="scroll"><m:mrow><m:mi>Φ</m:mi><m:mo>(</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow></m:math>, or of how
similar are <m:math overflow="scroll"><m:mi>x</m:mi></m:math> and <m:math overflow="scroll"><m:mi>z</m:mi></m:math>.</para>
      <para id="id74346">Given this intuition, suppose that for some learning problem that you're working on, you've
come up with some function <m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow></m:math> that you think might be a reasonable measure of how similar
<m:math overflow="scroll"><m:mi>x</m:mi></m:math> and <m:math overflow="scroll"><m:mi>z</m:mi></m:math> are. For instance, perhaps you chose</para>
      <equation id="id74389">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mi>K</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>x</m:mi>
              <m:mo>,</m:mo>
              <m:mi>z</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:mo form="prefix">exp</m:mo>
            <m:mfenced separators="" open="(" close=")">
              <m:mo>-</m:mo>
              <m:mfrac>
                <m:mrow>
                  <m:mrow>
                    <m:mo>|</m:mo>
                    <m:mo>|</m:mo>
                    <m:mi>x</m:mi>
                  </m:mrow>
                  <m:mo>-</m:mo>
                  <m:msup>
                    <m:mrow>
                      <m:mi>z</m:mi>
                      <m:mo>|</m:mo>
                      <m:mo>|</m:mo>
                    </m:mrow>
                    <m:mn>2</m:mn>
                  </m:msup>
                </m:mrow>
                <m:mrow>
                  <m:mn>2</m:mn>
                  <m:msup>
                    <m:mi>σ</m:mi>
                    <m:mn>2</m:mn>
                  </m:msup>
                </m:mrow>
              </m:mfrac>
            </m:mfenced>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id74466">This is a resonable measure of <m:math overflow="scroll"><m:mi>x</m:mi></m:math> and <m:math overflow="scroll"><m:mi>z</m:mi></m:math>'s similarity, and is close to 1 when <m:math overflow="scroll"><m:mi>x</m:mi></m:math> and <m:math overflow="scroll"><m:mi>z</m:mi></m:math> are
close, and near 0 when <m:math overflow="scroll"><m:mi>x</m:mi></m:math> and <m:math overflow="scroll"><m:mi>z</m:mi></m:math> are far apart.
Can we use this definition of <m:math overflow="scroll"><m:mi>K</m:mi></m:math> as the kernel in an SVM? In this particular example, the answer is yes.
(This kernel is called the <emphasis effect="bold">Gaussian kernel</emphasis>, and corresponds to an infinite dimensional
feature mapping <m:math overflow="scroll"><m:mi>Φ</m:mi></m:math>.) But more broadly, given some function <m:math overflow="scroll"><m:mi>K</m:mi></m:math>, how can we tell if it's a
valid kernel; i.e., can we tell if there is some feature mapping <m:math overflow="scroll"><m:mi>Φ</m:mi></m:math> so that <m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mi>Φ</m:mi><m:msup><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow><m:mi>T</m:mi></m:msup><m:mi>Φ</m:mi><m:mrow><m:mo>(</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:math>
for all <m:math overflow="scroll"><m:mi>x</m:mi></m:math>, <m:math overflow="scroll"><m:mi>z</m:mi></m:math>?</para>
      <para id="id74635">Suppose for now that <m:math overflow="scroll"><m:mi>K</m:mi></m:math> is indeed a valid kernel corresponding to some feature mapping <m:math overflow="scroll"><m:mi>Φ</m:mi></m:math>.
Now, consider some finite set of <m:math overflow="scroll"><m:mi>m</m:mi></m:math> points (not necessarily the training set)
<m:math overflow="scroll"><m:mrow><m:mo>{</m:mo><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mn>1</m:mn><m:mo>)</m:mo></m:mrow></m:msup><m:mo>,</m:mo><m:mo>...</m:mo><m:mo>,</m:mo><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mi>m</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>}</m:mo></m:mrow></m:math>, and let a square, <m:math overflow="scroll"><m:mi>m</m:mi></m:math>-by-<m:math overflow="scroll"><m:mi>m</m:mi></m:math> matrix <m:math overflow="scroll"><m:mi>K</m:mi></m:math> be defined so that
its <m:math overflow="scroll"><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>,</m:mo><m:mi>j</m:mi><m:mo>)</m:mo></m:mrow></m:math>-entry is given by <m:math overflow="scroll"><m:mrow><m:msub><m:mi>K</m:mi><m:mrow><m:mi>i</m:mi><m:mi>j</m:mi></m:mrow></m:msub><m:mo>=</m:mo><m:mi>K</m:mi><m:mrow><m:mo>(</m:mo><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>,</m:mo><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mi>j</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>)</m:mo></m:mrow></m:mrow></m:math>. This matrix is called the <emphasis effect="bold">Kernel matrix</emphasis>.
Note that we've overloaded the notation and used <m:math overflow="scroll"><m:mi>K</m:mi></m:math> to denote both the kernel function <m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow></m:math>
and the kernel matrix <m:math overflow="scroll"><m:mi>K</m:mi></m:math>, due to their obvious close relationship.</para>
      <para id="id74857">Now, if <m:math overflow="scroll"><m:mi>K</m:mi></m:math> is a valid Kernel, then <m:math overflow="scroll"><m:mrow><m:msub><m:mi>K</m:mi><m:mrow><m:mi>i</m:mi><m:mi>j</m:mi></m:mrow></m:msub><m:mo>=</m:mo><m:mi>K</m:mi><m:mrow><m:mo>(</m:mo><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>,</m:mo><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mi>j</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mi>Φ</m:mi><m:msup><m:mrow><m:mo>(</m:mo><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>)</m:mo></m:mrow><m:mi>T</m:mi></m:msup><m:mi>Φ</m:mi><m:mrow><m:mo>(</m:mo><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mi>j</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mi>Φ</m:mi><m:msup><m:mrow><m:mo>(</m:mo><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mi>j</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>)</m:mo></m:mrow><m:mi>T</m:mi></m:msup><m:mi>Φ</m:mi><m:mrow><m:mo>(</m:mo><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mi>K</m:mi><m:mrow><m:mo>(</m:mo><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mi>j</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>,</m:mo><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mi>i</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:msub><m:mi>K</m:mi><m:mrow><m:mi>j</m:mi><m:mi>i</m:mi></m:mrow></m:msub></m:mrow></m:math>, and hence <m:math overflow="scroll"><m:mi>K</m:mi></m:math> must be symmetric.
Moreover, letting <m:math overflow="scroll"><m:mrow><m:msub><m:mi>Φ</m:mi><m:mi>k</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:math> denote the <m:math overflow="scroll"><m:mi>k</m:mi></m:math>-th coordinate of the
vector <m:math overflow="scroll"><m:mrow><m:mi>Φ</m:mi><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow></m:math>, we find that for any vector <m:math overflow="scroll"><m:mi>z</m:mi></m:math>, we have</para>
      <equation id="id75138">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:msup>
                    <m:mi>z</m:mi>
                    <m:mi>T</m:mi>
                  </m:msup>
                  <m:mi>K</m:mi>
                  <m:mi>z</m:mi>
                </m:mrow>
              </m:mtd>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:munder>
                    <m:mo>∑</m:mo>
                    <m:mi>i</m:mi>
                  </m:munder>
                  <m:munder>
                    <m:mo>∑</m:mo>
                    <m:mi>j</m:mi>
                  </m:munder>
                  <m:msub>
                    <m:mi>z</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:msub>
                    <m:mi>K</m:mi>
                    <m:mrow>
                      <m:mi>i</m:mi>
                      <m:mi>j</m:mi>
                    </m:mrow>
                  </m:msub>
                  <m:msub>
                    <m:mi>z</m:mi>
                    <m:mi>j</m:mi>
                  </m:msub>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:munder>
                    <m:mo>∑</m:mo>
                    <m:mi>i</m:mi>
                  </m:munder>
                  <m:munder>
                    <m:mo>∑</m:mo>
                    <m:mi>j</m:mi>
                  </m:munder>
                  <m:msub>
                    <m:mi>z</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:mi>Φ</m:mi>
                  <m:msup>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:msup>
                        <m:mi>x</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:mi>i</m:mi>
                          <m:mo>)</m:mo>
                        </m:mrow>
                      </m:msup>
                      <m:mo>)</m:mo>
                    </m:mrow>
                    <m:mi>T</m:mi>
                  </m:msup>
                  <m:mi>Φ</m:mi>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msup>
                      <m:mi>x</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>j</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msup>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:msub>
                    <m:mi>z</m:mi>
                    <m:mi>j</m:mi>
                  </m:msub>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:munder>
                    <m:mo>∑</m:mo>
                    <m:mi>i</m:mi>
                  </m:munder>
                  <m:munder>
                    <m:mo>∑</m:mo>
                    <m:mi>j</m:mi>
                  </m:munder>
                  <m:msub>
                    <m:mi>z</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:munder>
                    <m:mo>∑</m:mo>
                    <m:mi>k</m:mi>
                  </m:munder>
                  <m:msub>
                    <m:mi>Φ</m:mi>
                    <m:mi>k</m:mi>
                  </m:msub>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msup>
                      <m:mi>x</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>i</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msup>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:msub>
                    <m:mi>Φ</m:mi>
                    <m:mi>k</m:mi>
                  </m:msub>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msup>
                      <m:mi>x</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>j</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msup>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:msub>
                    <m:mi>z</m:mi>
                    <m:mi>j</m:mi>
                  </m:msub>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:munder>
                    <m:mo>∑</m:mo>
                    <m:mi>k</m:mi>
                  </m:munder>
                  <m:munder>
                    <m:mo>∑</m:mo>
                    <m:mi>i</m:mi>
                  </m:munder>
                  <m:munder>
                    <m:mo>∑</m:mo>
                    <m:mi>j</m:mi>
                  </m:munder>
                  <m:msub>
                    <m:mi>z</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:msub>
                    <m:mi>Φ</m:mi>
                    <m:mi>k</m:mi>
                  </m:msub>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msup>
                      <m:mi>x</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>i</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msup>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:msub>
                    <m:mi>Φ</m:mi>
                    <m:mi>k</m:mi>
                  </m:msub>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msup>
                      <m:mi>x</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>j</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msup>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:msub>
                    <m:mi>z</m:mi>
                    <m:mi>j</m:mi>
                  </m:msub>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>=</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:munder>
                    <m:mo>∑</m:mo>
                    <m:mi>k</m:mi>
                  </m:munder>
                  <m:msup>
                    <m:mfenced separators="" open="(" close=")">
                      <m:munder>
                        <m:mo>∑</m:mo>
                        <m:mi>i</m:mi>
                      </m:munder>
                      <m:msub>
                        <m:mi>z</m:mi>
                        <m:mi>i</m:mi>
                      </m:msub>
                      <m:msub>
                        <m:mi>Φ</m:mi>
                        <m:mi>k</m:mi>
                      </m:msub>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:msup>
                          <m:mi>x</m:mi>
                          <m:mrow>
                            <m:mo>(</m:mo>
                            <m:mi>i</m:mi>
                            <m:mo>)</m:mo>
                          </m:mrow>
                        </m:msup>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:mfenced>
                    <m:mn>2</m:mn>
                  </m:msup>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mo>≥</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mn>0</m:mn>
                  <m:mo>.</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id75586">The second-to-last step above used the same trick as you saw in Problem set 1 Q1. Since
<m:math overflow="scroll"><m:mi>z</m:mi></m:math> was arbitrary, this shows that <m:math overflow="scroll"><m:mi>K</m:mi></m:math> is positive semi-definite (<m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mo>≥</m:mo><m:mn>0</m:mn></m:mrow></m:math>).</para>
      <para id="id75625">Hence, we've shown that if <m:math overflow="scroll"><m:mi>K</m:mi></m:math> is a valid kernel (i.e., if it corresponds to some feature
mapping <m:math overflow="scroll"><m:mi>Φ</m:mi></m:math>), then the corresponding Kernel matrix <m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mo>∈</m:mo><m:msup><m:mrow><m:mi mathvariant="double-struck">R</m:mi></m:mrow><m:mrow><m:mi>m</m:mi><m:mo>×</m:mo><m:mi>m</m:mi></m:mrow></m:msup></m:mrow></m:math> is symmetric
positive semidefinite. More generally, this turns out to be not only a necessary, but
also a sufficient, condition for <m:math overflow="scroll"><m:mi>K</m:mi></m:math> to be a valid kernel (also called a Mercer kernel).
The following result is due to Mercer.<footnote id="uid15">Many texts present Mercer's
theorem in a slightly more complicated form involving <m:math overflow="scroll"><m:msup><m:mi>L</m:mi><m:mn>2</m:mn></m:msup></m:math> functions, but
when the input attributes take values in <m:math overflow="scroll"><m:msup><m:mrow><m:mi mathvariant="double-struck">R</m:mi></m:mrow><m:mi>n</m:mi></m:msup></m:math>,
the version given here is equivalent.</footnote></para>
      <para id="id75727"><emphasis effect="bold">Theorem (Mercer).</emphasis> Let <m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mo>:</m:mo><m:msup><m:mrow><m:mi mathvariant="double-struck">R</m:mi></m:mrow><m:mi>n</m:mi></m:msup><m:mo>×</m:mo><m:msup><m:mrow><m:mi mathvariant="double-struck">R</m:mi></m:mrow><m:mi>n</m:mi></m:msup><m:mo>↦</m:mo><m:mi mathvariant="double-struck">R</m:mi></m:mrow></m:math> be given. Then for <m:math overflow="scroll"><m:mi>K</m:mi></m:math> to
be a valid (Mercer) kernel, it is necessary and sufficient that for any <m:math overflow="scroll"><m:mrow><m:mo>{</m:mo><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mn>1</m:mn><m:mo>)</m:mo></m:mrow></m:msup><m:mo>,</m:mo><m:mo>...</m:mo><m:mo>,</m:mo><m:msup><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mi>m</m:mi><m:mo>)</m:mo></m:mrow></m:msup><m:mo>}</m:mo></m:mrow></m:math>,
(<m:math overflow="scroll"><m:mrow><m:mi>m</m:mi><m:mo>&lt;</m:mo><m:mi>∞</m:mi></m:mrow></m:math>), the corresponding kernel matrix is symmetric positive semi-definite.</para>
      <para id="id75852">Given a function <m:math overflow="scroll"><m:mi>K</m:mi></m:math>, apart from trying to find a feature mapping <m:math overflow="scroll"><m:mi>Φ</m:mi></m:math> that corresponds
to it, this theorem therefore gives another way of testing if it is a valid kernel.
You'll also have a chance to play with these ideas more in problem set 2.</para>
      <para id="id75877">In class, we also briefly talked about a couple of other examples of kernels. For instance,
consider the digit recognition problem, in which given an image (16x16 pixels) of a handwritten
digit (0-9), we have to figure out which digit it was. Using either a simple polynomial
kernel <m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:msup><m:mrow><m:mo>(</m:mo><m:msup><m:mi>x</m:mi><m:mi>T</m:mi></m:msup><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow><m:mi>d</m:mi></m:msup></m:mrow></m:math> or the Gaussian
kernel, SVMs were able to obtain extremely good performance on this problem.
This was particularly surprising since the input attributes <m:math overflow="scroll"><m:mi>x</m:mi></m:math> were just a 256-dimensional
vector of the image pixel intensity values, and the system had no prior knowledge about vision,
or even about which pixels are adjacent to which other ones. Another example that we briefly
talked about in lecture was that if the objects <m:math overflow="scroll"><m:mi>x</m:mi></m:math> that we are trying to classify are strings (say, <m:math overflow="scroll"><m:mi>x</m:mi></m:math> is a list of amino
acids, which strung together form a protein), then it seems hard to construct a reasonable, “small”
set of features for most learning algorithms, especially if different strings have different lengths.
However, consider letting <m:math overflow="scroll"><m:mrow><m:mi>Φ</m:mi><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow></m:math> be a feature vector that counts the
number of occurrences of each length-<m:math overflow="scroll"><m:mi>k</m:mi></m:math> substring in <m:math overflow="scroll"><m:mi>x</m:mi></m:math>. If we're considering strings of english
letters, then there are <m:math overflow="scroll"><m:msup><m:mn>26</m:mn><m:mi>k</m:mi></m:msup></m:math> such strings. Hence, <m:math overflow="scroll"><m:mrow><m:mi>Φ</m:mi><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow></m:math> is a <m:math overflow="scroll"><m:msup><m:mn>26</m:mn><m:mi>k</m:mi></m:msup></m:math> dimensional vector;
even for moderate values of <m:math overflow="scroll"><m:mi>k</m:mi></m:math>, this is probably too big for us to efficiently work with.
(e.g., <m:math overflow="scroll"><m:mrow><m:msup><m:mn>26</m:mn><m:mn>4</m:mn></m:msup><m:mo>≈</m:mo><m:mn>460000</m:mn></m:mrow></m:math>.) However, using
(dynamic programming-ish) string matching algorithms, it is possible to efficiently
compute <m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mi>Φ</m:mi><m:msup><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow><m:mi>T</m:mi></m:msup><m:mi>Φ</m:mi><m:mrow><m:mo>(</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:math>, so that we can now implicitly work in this <m:math overflow="scroll"><m:msup><m:mn>26</m:mn><m:mi>k</m:mi></m:msup></m:math>-dimensional
feature space, but without ever explicitly computing feature vectors in this space.</para>
      <para id="id76135">The application of kernels to support vector machines should already be clear and so we won't
dwell too much longer on it here. Keep in mind however that the idea of kernels has
significantly broader applicability than SVMs. Specifically, if you have any learning
algorithm that you can write in terms of only inner products
<m:math overflow="scroll"><m:mrow><m:mo>〈</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>〉</m:mo></m:mrow></m:math> between input attribute vectors, then by replacing this with <m:math overflow="scroll"><m:mrow><m:mi>K</m:mi><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow></m:math> where
<m:math overflow="scroll"><m:mi>K</m:mi></m:math> is a kernel, you can “magically” allow your algorithm to work efficiently in the high dimensional
feature space corresponding to <m:math overflow="scroll"><m:mi>K</m:mi></m:math>. For instance, this kernel trick can be applied with the perceptron
to to derive a kernel perceptron algorithm. Many of the algorithms that we'll see later in this
class will also be amenable to this method, which has come to be known as the “kernel trick.”</para>
    </section>
    <section id="cid9">
      <title>Regularization and the non-separable case</title>
      <para id="id76215">The derivation of the SVM as presented so far assumed that the data is linearly separable.
While mapping data to a high dimensional feature space via <m:math overflow="scroll"><m:mi>Φ</m:mi></m:math> does generally increase
the likelihood that the data is separable, we can't guarantee that it always will be so.
Also, in some cases it is not clear that finding a separating hyperplane is exactly what we'd want
to do, since that might
be susceptible to outliers. For instance, the left figure below shows an optimal margin classifier,
and when a single outlier is added in the upper-left region (right figure), it causes the decision
boundary to make a dramatic swing, and the resulting classifier has a much smaller margin.</para>
      <para id="id76233">
        <figure id="id76234"><media id="id76234_media" alt="the original data set with a line drawn through it">
            <image mime-type="image/png" src="../../media/outlier.png" id="id76234_onlineimage" width="349"><!-- NOTE: attribute width changes image size online (pixels). original width is 349. --></image>
            <image mime-type="application/postscript" for="pdf" print-width="3.5in" src="../../media/outlier.eps" id="id76234_printimage"/>
          </media>
        </figure><figure id="id76240"><media id="id76240_media" alt="same data set and line with an intersecting line">
            <image mime-type="image/png" src="../../media/outlier2.png" id="id76240_onlineimage" width="349"><!-- NOTE: attribute width changes image size online (pixels). original width is 349. --></image>
            <image mime-type="application/postscript" for="pdf" print-width="3.5in" src="../../media/outlier2.eps" id="id76240_printimage"/>
          </media>
        </figure></para>
      <para id="id76247">To make the algorithm work for non-linearly separable datasets as well as be less sensitive
to outliers, we reformulate our optimization (using <emphasis effect="bold"><m:math overflow="scroll"><m:msub><m:mi>ℓ</m:mi><m:mn>1</m:mn></m:msub></m:math> regularization</emphasis>) as follows:</para>
      <equation id="id76271">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:msub>
                  <m:mtext>min</m:mtext>
                  <m:mrow>
                    <m:mi>γ</m:mi>
                    <m:mo>,</m:mo>
                    <m:mi>w</m:mi>
                    <m:mo>,</m:mo>
                    <m:mi>b</m:mi>
                  </m:mrow>
                </m:msub>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mfrac>
                    <m:mn>1</m:mn>
                    <m:mn>2</m:mn>
                  </m:mfrac>
                  <m:msup>
                    <m:mrow>
                      <m:mo>|</m:mo>
                      <m:mo>|</m:mo>
                      <m:mi>w</m:mi>
                      <m:mo>|</m:mo>
                      <m:mo>|</m:mo>
                    </m:mrow>
                    <m:mn>2</m:mn>
                  </m:msup>
                  <m:mo>+</m:mo>
                  <m:mi>C</m:mi>
                  <m:munderover>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:mi>i</m:mi>
                      <m:mo>=</m:mo>
                      <m:mn>1</m:mn>
                    </m:mrow>
                    <m:mi>m</m:mi>
                  </m:munderover>
                  <m:msub>
                    <m:mi>ξ</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mrow>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mtext>s.t.</m:mtext>
                </m:mrow>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:msup>
                    <m:mi>y</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>i</m:mi>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:msup>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msup>
                      <m:mi>w</m:mi>
                      <m:mi>T</m:mi>
                    </m:msup>
                    <m:msup>
                      <m:mi>x</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>i</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msup>
                    <m:mo>+</m:mo>
                    <m:mi>b</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>≥</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>-</m:mo>
                  <m:msub>
                    <m:mi>ξ</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:mo>,</m:mo>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mi>i</m:mi>
                  <m:mo>=</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>,</m:mo>
                  <m:mo>...</m:mo>
                  <m:mo>,</m:mo>
                  <m:mi>m</m:mi>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd/>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:msub>
                    <m:mi>ξ</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:mo>≥</m:mo>
                  <m:mn>0</m:mn>
                  <m:mo>,</m:mo>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mi>i</m:mi>
                  <m:mo>=</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>,</m:mo>
                  <m:mo>...</m:mo>
                  <m:mo>,</m:mo>
                  <m:mi>m</m:mi>
                  <m:mo>.</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id76520">Thus, examples are now permitted to have (functional) margin less than 1, and if an example
has functional margin <m:math overflow="scroll"><m:mrow><m:mn>1</m:mn><m:mo>-</m:mo><m:msub><m:mi>ξ</m:mi><m:mi>i</m:mi></m:msub></m:mrow></m:math> (with <m:math overflow="scroll"><m:mrow><m:mi>ξ</m:mi><m:mo>&gt;</m:mo><m:mn>0</m:mn></m:mrow></m:math>), we would pay a cost of the objective function being
increased by <m:math overflow="scroll"><m:mrow><m:mi>C</m:mi><m:msub><m:mi>ξ</m:mi><m:mi>i</m:mi></m:msub></m:mrow></m:math>. The parameter <m:math overflow="scroll"><m:mi>C</m:mi></m:math> controls the relative weighting between the
twin goals of making the <m:math overflow="scroll"><m:msup><m:mrow><m:mo>|</m:mo><m:mo>|</m:mo><m:mi>w</m:mi><m:mo>|</m:mo><m:mo>|</m:mo></m:mrow><m:mn>2</m:mn></m:msup></m:math> small (which we saw earlier makes the margin large)
and of ensuring that most examples have functional margin at least 1.</para>
      <para id="id76613">As before, we can form the Lagrangian:</para>
      <equation id="id76617">
        <m:math overflow="scroll" mode="display">
          <m:mrow>
            <m:mi mathvariant="script">L</m:mi>
            <m:mrow>
              <m:mo>(</m:mo>
              <m:mi>w</m:mi>
              <m:mo>,</m:mo>
              <m:mi>b</m:mi>
              <m:mo>,</m:mo>
              <m:mi>ξ</m:mi>
              <m:mo>,</m:mo>
              <m:mi>α</m:mi>
              <m:mo>,</m:mo>
              <m:mi>r</m:mi>
              <m:mo>)</m:mo>
            </m:mrow>
            <m:mo>=</m:mo>
            <m:mfrac>
              <m:mn>1</m:mn>
              <m:mn>2</m:mn>
            </m:mfrac>
            <m:msup>
              <m:mi>w</m:mi>
              <m:mi>T</m:mi>
            </m:msup>
            <m:mi>w</m:mi>
            <m:mo>+</m:mo>
            <m:mi>C</m:mi>
            <m:munderover>
              <m:mo>∑</m:mo>
              <m:mrow>
                <m:mi>i</m:mi>
                <m:mo>=</m:mo>
                <m:mn>1</m:mn>
              </m:mrow>
              <m:mi>m</m:mi>
            </m:munderover>
            <m:msub>
              <m:mi>ξ</m:mi>
              <m:mi>i</m:mi>
            </m:msub>
            <m:mo>-</m:mo>
            <m:munderover>
              <m:mo>∑</m:mo>
              <m:mrow>
                <m:mi>i</m:mi>
                <m:mo>=</m:mo>
                <m:mn>1</m:mn>
              </m:mrow>
              <m:mi>m</m:mi>
            </m:munderover>
            <m:msub>
              <m:mi>α</m:mi>
              <m:mi>i</m:mi>
            </m:msub>
            <m:mfenced separators="" open="[" close="]">
              <m:msup>
                <m:mi>y</m:mi>
                <m:mrow>
                  <m:mo>(</m:mo>
                  <m:mi>i</m:mi>
                  <m:mo>)</m:mo>
                </m:mrow>
              </m:msup>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:msup>
                  <m:mi>x</m:mi>
                  <m:mi>T</m:mi>
                </m:msup>
                <m:mi>w</m:mi>
                <m:mo>+</m:mo>
                <m:mi>b</m:mi>
                <m:mo>)</m:mo>
              </m:mrow>
              <m:mo>-</m:mo>
              <m:mn>1</m:mn>
              <m:mo>+</m:mo>
              <m:msub>
                <m:mi>ξ</m:mi>
                <m:mi>i</m:mi>
              </m:msub>
            </m:mfenced>
            <m:mo>-</m:mo>
            <m:munderover>
              <m:mo>∑</m:mo>
              <m:mrow>
                <m:mi>i</m:mi>
                <m:mo>=</m:mo>
                <m:mn>1</m:mn>
              </m:mrow>
              <m:mi>m</m:mi>
            </m:munderover>
            <m:msub>
              <m:mi>r</m:mi>
              <m:mi>i</m:mi>
            </m:msub>
            <m:msub>
              <m:mi>ξ</m:mi>
              <m:mi>i</m:mi>
            </m:msub>
            <m:mo>.</m:mo>
          </m:mrow>
        </m:math>
      </equation>
      <para id="id76818">Here, the <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mi>i</m:mi></m:msub></m:math>'s and <m:math overflow="scroll"><m:msub><m:mi>r</m:mi><m:mi>i</m:mi></m:msub></m:math>'s are our Lagrange multipliers (constrained to be <m:math overflow="scroll"><m:mrow><m:mo>≥</m:mo><m:mn>0</m:mn></m:mrow></m:math>). We
won't go through the derivation of the dual again in detail, but after setting the derivatives with respect
to <m:math overflow="scroll"><m:mi>w</m:mi></m:math> and <m:math overflow="scroll"><m:mi>b</m:mi></m:math> to zero as before, substituting them back in, and simplifying, we obtain the
following dual form of the problem:</para>
      <equation id="id76885">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:msub>
                  <m:mtext>max</m:mtext>
                  <m:mi>α</m:mi>
                </m:msub>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mi>W</m:mi>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mi>α</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>=</m:mo>
                  <m:munderover>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:mi>i</m:mi>
                      <m:mo>=</m:mo>
                      <m:mn>1</m:mn>
                    </m:mrow>
                    <m:mi>m</m:mi>
                  </m:munderover>
                  <m:msub>
                    <m:mi>α</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:mo>-</m:mo>
                  <m:mfrac>
                    <m:mn>1</m:mn>
                    <m:mn>2</m:mn>
                  </m:mfrac>
                  <m:munderover>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:mi>i</m:mi>
                      <m:mo>,</m:mo>
                      <m:mi>j</m:mi>
                      <m:mo>=</m:mo>
                      <m:mn>1</m:mn>
                    </m:mrow>
                    <m:mi>m</m:mi>
                  </m:munderover>
                  <m:msup>
                    <m:mi>y</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>i</m:mi>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:msup>
                  <m:msup>
                    <m:mi>y</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>j</m:mi>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:msup>
                  <m:msub>
                    <m:mi>α</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:msub>
                    <m:mi>α</m:mi>
                    <m:mi>j</m:mi>
                  </m:msub>
                  <m:mrow>
                    <m:mo>〈</m:mo>
                    <m:msup>
                      <m:mi>x</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>i</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msup>
                    <m:mo>,</m:mo>
                    <m:msup>
                      <m:mi>x</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>j</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msup>
                    <m:mo>〉</m:mo>
                  </m:mrow>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd>
                <m:mrow>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mtext>s.t.</m:mtext>
                </m:mrow>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:mn>0</m:mn>
                  <m:mo>≤</m:mo>
                  <m:msub>
                    <m:mi>α</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:mo>≤</m:mo>
                  <m:mi>C</m:mi>
                  <m:mo>,</m:mo>
                  <m:mspace width="0.277778em"/>
                  <m:mspace width="0.277778em"/>
                  <m:mi>i</m:mi>
                  <m:mo>=</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>,</m:mo>
                  <m:mo>...</m:mo>
                  <m:mo>,</m:mo>
                  <m:mi>m</m:mi>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd/>
              <m:mtd/>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:munderover>
                    <m:mo>∑</m:mo>
                    <m:mrow>
                      <m:mi>i</m:mi>
                      <m:mo>=</m:mo>
                      <m:mn>1</m:mn>
                    </m:mrow>
                    <m:mi>m</m:mi>
                  </m:munderover>
                  <m:msub>
                    <m:mi>α</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:msup>
                    <m:mi>y</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>i</m:mi>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:msup>
                  <m:mo>=</m:mo>
                  <m:mn>0</m:mn>
                  <m:mo>,</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id77166">As before, we also have that <m:math overflow="scroll"><m:mi>w</m:mi></m:math> can be expressed in terms of the <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mi>i</m:mi></m:msub></m:math>'s as given in <link target-id="uid11"/>, so that after solving the dual problem, we can continue to
use <link target-id="uid14"/> to make our predictions. Note that, somewhat surprisingly, in
adding <m:math overflow="scroll"><m:msub><m:mi>ℓ</m:mi><m:mn>1</m:mn></m:msub></m:math> regularization, the only change to the dual problem is that what was
originally a constraint that <m:math overflow="scroll"><m:mrow><m:mn>0</m:mn><m:mo>≤</m:mo><m:msub><m:mi>α</m:mi><m:mi>i</m:mi></m:msub></m:mrow></m:math> has now become <m:math overflow="scroll"><m:mrow><m:mn>0</m:mn><m:mo>≤</m:mo><m:msub><m:mi>α</m:mi><m:mi>i</m:mi></m:msub><m:mo>≤</m:mo><m:mi>C</m:mi></m:mrow></m:math>.
The calculation for <m:math overflow="scroll"><m:msup><m:mi>b</m:mi><m:mo>*</m:mo></m:msup></m:math> also has to be modified (<link target-id="uid13"/> is no longer valid);
see the comments in the next section/Platt's paper.</para><para id="id77285">Also, the KKT dual-complementarity conditions (which in the next section will be useful for testing
for the convergence of the SMO algorithm) are:
</para>
      <equation id="uid16">
        <m:math overflow="scroll" mode="display">
          <m:mtable displaystyle="true">
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:msub>
                    <m:mi>α</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:mo>=</m:mo>
                  <m:mn>0</m:mn>
                </m:mrow>
              </m:mtd>
              <m:mtd>
                <m:mo>⇒</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:msup>
                    <m:mi>y</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>i</m:mi>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:msup>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msup>
                      <m:mi>w</m:mi>
                      <m:mi>T</m:mi>
                    </m:msup>
                    <m:msup>
                      <m:mi>x</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>i</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msup>
                    <m:mo>+</m:mo>
                    <m:mi>b</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>≥</m:mo>
                  <m:mn>1</m:mn>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:msub>
                    <m:mi>α</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:mo>=</m:mo>
                  <m:mi>C</m:mi>
                </m:mrow>
              </m:mtd>
              <m:mtd>
                <m:mo>⇒</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:msup>
                    <m:mi>y</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>i</m:mi>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:msup>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msup>
                      <m:mi>w</m:mi>
                      <m:mi>T</m:mi>
                    </m:msup>
                    <m:msup>
                      <m:mi>x</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>i</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msup>
                    <m:mo>+</m:mo>
                    <m:mi>b</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>≤</m:mo>
                  <m:mn>1</m:mn>
                </m:mrow>
              </m:mtd>
            </m:mtr>
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mrow>
                  <m:mn>0</m:mn>
                  <m:mo>&lt;</m:mo>
                  <m:msub>
                    <m:mi>α</m:mi>
                    <m:mi>i</m:mi>
                  </m:msub>
                  <m:mo>&lt;</m:mo>
                  <m:mi>C</m:mi>
                </m:mrow>
              </m:mtd>
              <m:mtd>
                <m:mo>⇒</m:mo>
              </m:mtd>
              <m:mtd columnalign="left">
                <m:mrow>
                  <m:msup>
                    <m:mi>y</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>i</m:mi>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:msup>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:msup>
                      <m:mi>w</m:mi>
                      <m:mi>T</m:mi>
                    </m:msup>
                    <m:msup>
                      <m:mi>x</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>i</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msup>
                    <m:mo>+</m:mo>
                    <m:mi>b</m:mi>
                    <m:mo>)</m:mo>
                  </m:mrow>
                  <m:mo>=</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>.</m:mo>
                </m:mrow>
              </m:mtd>
            </m:mtr>
          </m:mtable>
        </m:math>
      </equation>
      <para id="id77537">Now, all that remains is to give an algorithm for actually solving the dual problem, which we
will do in the next section.</para>
    </section>
    <section id="cid10">
      <title>The SMO algorithm</title>
      <para id="id77552">The SMO (sequential minimal optimization) algorithm, due to John Platt, gives an efficient
way of solving the dual problem arising from the derivation of the SVM. Partly to motivate
the SMO algorithm, and partly because it's interesting in its own right, let's first take
another digression to talk about the coordinate ascent algorithm.</para>
      <section id="uid17">
        <title>Coordinate ascent</title>
        <para id="id77566">Consider trying to solve the unconstrained optimization problem</para>
        <equation id="id77570">
          <m:math overflow="scroll" mode="display">
            <m:mrow>
              <m:munder>
                <m:mo movablelimits="true" form="prefix">max</m:mo>
                <m:mi>α</m:mi>
              </m:munder>
              <m:mi>W</m:mi>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:msub>
                  <m:mi>α</m:mi>
                  <m:mn>1</m:mn>
                </m:msub>
                <m:mo>,</m:mo>
                <m:msub>
                  <m:mi>α</m:mi>
                  <m:mn>2</m:mn>
                </m:msub>
                <m:mo>,</m:mo>
                <m:mo>...</m:mo>
                <m:mo>,</m:mo>
                <m:msub>
                  <m:mi>α</m:mi>
                  <m:mi>m</m:mi>
                </m:msub>
                <m:mo>)</m:mo>
              </m:mrow>
              <m:mo>.</m:mo>
            </m:mrow>
          </m:math>
        </equation>
        <para id="id77634">Here, we think of <m:math overflow="scroll"><m:mi>W</m:mi></m:math> as just some function of the parameters <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mi>i</m:mi></m:msub></m:math>'s,
and for now ignore any relationship between this problem and SVMs.
We've already seen two optimization algorithms, gradient ascent and Newton's method.
The new algorithm we're going to consider here is called <emphasis effect="bold">coordinate ascent</emphasis>:</para>
        <list id="id77670" display="block" list-type="enumerated">
          <item id="uid18"><label/>Loop until convergence: <m:math overflow="scroll"><m:mo>{</m:mo></m:math></item>
          <item id="uid19">
            <label/>
            <list id="id77704" display="block" list-type="enumerated">
              <item id="uid20"><label/>For <m:math overflow="scroll"><m:mrow><m:mi>i</m:mi><m:mo>=</m:mo><m:mn>1</m:mn><m:mo>,</m:mo><m:mo>...</m:mo><m:mo>,</m:mo><m:mi>m</m:mi></m:mrow></m:math>, <m:math overflow="scroll"><m:mo>{</m:mo></m:math><list id="id77750" display="block" list-type="enumerated"><item id="uid21"><label/><m:math overflow="scroll"><m:mrow><m:msub><m:mi>α</m:mi><m:mi>i</m:mi></m:msub><m:mo>:</m:mo><m:mo>=</m:mo><m:mo form="prefix">arg</m:mo><m:msub><m:mo movablelimits="true" form="prefix">max</m:mo><m:msub><m:mover accent="true"><m:mi>α</m:mi><m:mo>^</m:mo></m:mover><m:mi>i</m:mi></m:msub></m:msub><m:mi>W</m:mi><m:mrow><m:mo>(</m:mo><m:msub><m:mi>α</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:mo>...</m:mo><m:mo>,</m:mo><m:msub><m:mi>α</m:mi><m:mrow><m:mi>i</m:mi><m:mo>-</m:mo><m:mn>1</m:mn></m:mrow></m:msub><m:mo>,</m:mo><m:msub><m:mover accent="true"><m:mi>α</m:mi><m:mo>^</m:mo></m:mover><m:mi>i</m:mi></m:msub><m:mo>,</m:mo><m:msub><m:mi>α</m:mi><m:mrow><m:mi>i</m:mi><m:mo>+</m:mo><m:mn>1</m:mn></m:mrow></m:msub><m:mo>,</m:mo><m:mo>...</m:mo><m:mo>,</m:mo><m:msub><m:mi>α</m:mi><m:mi>m</m:mi></m:msub><m:mo>)</m:mo></m:mrow></m:mrow></m:math>.
</item></list></item>
              <item id="uid22">
                <label/>
                <m:math overflow="scroll">
                  <m:mo>}</m:mo>
                </m:math>
              </item>
            </list>
          </item>
          <item id="uid23">
            <label/>
            <m:math overflow="scroll">
              <m:mo>}</m:mo>
            </m:math>
          </item>
        </list>
        <para id="id77937">Thus, in the innermost loop of this algorithm, we will hold all the variables except
for some <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mi>i</m:mi></m:msub></m:math> fixed, and reoptimize <m:math overflow="scroll"><m:mi>W</m:mi></m:math> with respect to just the parameter <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mi>i</m:mi></m:msub></m:math>.
In the version of this method presented here, the inner-loop reoptimizes the
variables in order <m:math overflow="scroll"><m:mrow><m:msub><m:mi>α</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:msub><m:mi>α</m:mi><m:mn>2</m:mn></m:msub><m:mo>,</m:mo><m:mo>...</m:mo><m:mo>,</m:mo><m:msub><m:mi>α</m:mi><m:mi>m</m:mi></m:msub><m:mo>,</m:mo><m:msub><m:mi>α</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:msub><m:mi>α</m:mi><m:mn>2</m:mn></m:msub><m:mo>,</m:mo><m:mo>...</m:mo></m:mrow></m:math>.
(A more sophisticated version might choose other orderings; for instance, we may
choose the next variable to update according to which one we expect to allow us to
make the largest
increase in <m:math overflow="scroll"><m:mrow><m:mi>W</m:mi><m:mo>(</m:mo><m:mi>α</m:mi><m:mo>)</m:mo></m:mrow></m:math>.)</para>
        <para id="id78061">When the function <m:math overflow="scroll"><m:mi>W</m:mi></m:math> happens to be of such a form that the “<m:math overflow="scroll"><m:mrow><m:mo form="prefix">arg</m:mo><m:mo movablelimits="true" form="prefix">max</m:mo></m:mrow></m:math>”
in the inner loop can be performed efficiently, then coordinate ascent can be a fairly
efficient algorithm. Here's a picture of coordinate ascent in action:</para>
        <figure id="uid24"><media id="uid24_media" alt="distribution rings with a zig zag line flowing through to each of the points">
            <image mime-type="image/png" src="../../media/coordinateAscent.png" id="uid24_onlineimage" width="480"><!-- NOTE: attribute width changes image size online (pixels). original width is 480. --></image>
            <image mime-type="application/postscript" for="pdf" print-width="3.5in" src="../../media/coordinateAscent.eps" id="uid24_printimage"/>
          </media>
        </figure><para id="id78102">The ellipses in the figure are the contours of a quadratic function that we want to optimize.
Coordinate
ascent was initialized at <m:math overflow="scroll"><m:mrow><m:mo>(</m:mo><m:mn>2</m:mn><m:mo>,</m:mo><m:mo>-</m:mo><m:mn>2</m:mn><m:mo>)</m:mo></m:mrow></m:math>, and also plotted in the figure is the path that it took
on its way to the global maximum. Notice that on each step, coordinate ascent takes a
step that's parallel to one of the axes, since only one variable is being optimized at a time.</para>
      </section>
      <section id="uid25">
        <title>SMO</title>
        <para id="id78139">We close off the discussion of SVMs by sketching the derivation of the SMO algorithm.
Some details will be left to the homework, and for others you may refer to the paper
excerpt handed out in class.</para>
        <para id="id78144">Here's the (dual) optimization problem that we want to solve:
</para>
        <equation id="uid26">
          <m:math overflow="scroll" mode="display">
            <m:mtable displaystyle="true">
              <m:mtr>
                <m:mtd/>
                <m:mtd>
                  <m:msub>
                    <m:mtext>max</m:mtext>
                    <m:mi>α</m:mi>
                  </m:msub>
                </m:mtd>
                <m:mtd columnalign="left">
                  <m:mrow>
                    <m:mi>W</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mi>α</m:mi>
                      <m:mo>)</m:mo>
                    </m:mrow>
                    <m:mo>=</m:mo>
                    <m:munderover>
                      <m:mo>∑</m:mo>
                      <m:mrow>
                        <m:mi>i</m:mi>
                        <m:mo>=</m:mo>
                        <m:mn>1</m:mn>
                      </m:mrow>
                      <m:mi>m</m:mi>
                    </m:munderover>
                    <m:msub>
                      <m:mi>α</m:mi>
                      <m:mi>i</m:mi>
                    </m:msub>
                    <m:mo>-</m:mo>
                    <m:mfrac>
                      <m:mn>1</m:mn>
                      <m:mn>2</m:mn>
                    </m:mfrac>
                    <m:munderover>
                      <m:mo>∑</m:mo>
                      <m:mrow>
                        <m:mi>i</m:mi>
                        <m:mo>,</m:mo>
                        <m:mi>j</m:mi>
                        <m:mo>=</m:mo>
                        <m:mn>1</m:mn>
                      </m:mrow>
                      <m:mi>m</m:mi>
                    </m:munderover>
                    <m:msup>
                      <m:mi>y</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>i</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msup>
                    <m:msup>
                      <m:mi>y</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>j</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msup>
                    <m:msub>
                      <m:mi>α</m:mi>
                      <m:mi>i</m:mi>
                    </m:msub>
                    <m:msub>
                      <m:mi>α</m:mi>
                      <m:mi>j</m:mi>
                    </m:msub>
                    <m:mrow>
                      <m:mo>〈</m:mo>
                      <m:msup>
                        <m:mi>x</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:mi>i</m:mi>
                          <m:mo>)</m:mo>
                        </m:mrow>
                      </m:msup>
                      <m:mo>,</m:mo>
                      <m:msup>
                        <m:mi>x</m:mi>
                        <m:mrow>
                          <m:mo>(</m:mo>
                          <m:mi>j</m:mi>
                          <m:mo>)</m:mo>
                        </m:mrow>
                      </m:msup>
                      <m:mo>〉</m:mo>
                    </m:mrow>
                    <m:mo>.</m:mo>
                  </m:mrow>
                </m:mtd>
              </m:mtr>
              <m:mtr>
                <m:mtd/>
                <m:mtd>
                  <m:mrow>
                    <m:mspace width="0.277778em"/>
                    <m:mspace width="0.277778em"/>
                    <m:mspace width="0.277778em"/>
                    <m:mspace width="0.277778em"/>
                    <m:mtext>s.t.</m:mtext>
                  </m:mrow>
                </m:mtd>
                <m:mtd columnalign="left">
                  <m:mrow>
                    <m:mn>0</m:mn>
                    <m:mo>≤</m:mo>
                    <m:msub>
                      <m:mi>α</m:mi>
                      <m:mi>i</m:mi>
                    </m:msub>
                    <m:mo>≤</m:mo>
                    <m:mi>C</m:mi>
                    <m:mo>,</m:mo>
                    <m:mspace width="0.277778em"/>
                    <m:mspace width="0.277778em"/>
                    <m:mi>i</m:mi>
                    <m:mo>=</m:mo>
                    <m:mn>1</m:mn>
                    <m:mo>,</m:mo>
                    <m:mo>...</m:mo>
                    <m:mo>,</m:mo>
                    <m:mi>m</m:mi>
                  </m:mrow>
                </m:mtd>
              </m:mtr>
              <m:mtr>
                <m:mtd/>
                <m:mtd/>
                <m:mtd columnalign="left">
                  <m:mrow>
                    <m:munderover>
                      <m:mo>∑</m:mo>
                      <m:mrow>
                        <m:mi>i</m:mi>
                        <m:mo>=</m:mo>
                        <m:mn>1</m:mn>
                      </m:mrow>
                      <m:mi>m</m:mi>
                    </m:munderover>
                    <m:msub>
                      <m:mi>α</m:mi>
                      <m:mi>i</m:mi>
                    </m:msub>
                    <m:msup>
                      <m:mi>y</m:mi>
                      <m:mrow>
                        <m:mo>(</m:mo>
                        <m:mi>i</m:mi>
                        <m:mo>)</m:mo>
                      </m:mrow>
                    </m:msup>
                    <m:mo>=</m:mo>
                    <m:mn>0</m:mn>
                    <m:mo>.</m:mo>
                  </m:mrow>
                </m:mtd>
              </m:mtr>
            </m:mtable>
          </m:math>
        </equation>
        <para id="id78444">Let's say we have set of <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mi>i</m:mi></m:msub></m:math>'s that satisfy the
constraints the second two equations in <link target-id="uid26"/>. Now, suppose we want to
hold <m:math overflow="scroll"><m:mrow><m:msub><m:mi>α</m:mi><m:mn>2</m:mn></m:msub><m:mo>,</m:mo><m:mo>...</m:mo><m:mo>,</m:mo><m:msub><m:mi>α</m:mi><m:mi>m</m:mi></m:msub></m:mrow></m:math> fixed, and take a coordinate ascent step and reoptimize
the objective with respect to <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mn>1</m:mn></m:msub></m:math>. Can we make any progress? The answer is no, because the
constraint (last equation in <link target-id="uid26"/>) ensures that</para><equation id="id78518">
          <m:math overflow="scroll" mode="display">
            <m:mrow>
              <m:msub>
                <m:mi>α</m:mi>
                <m:mn>1</m:mn>
              </m:msub>
              <m:msup>
                <m:mi>y</m:mi>
                <m:mrow>
                  <m:mo>(</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>)</m:mo>
                </m:mrow>
              </m:msup>
              <m:mo>=</m:mo>
              <m:mo>-</m:mo>
              <m:munderover>
                <m:mo>∑</m:mo>
                <m:mrow>
                  <m:mi>i</m:mi>
                  <m:mo>=</m:mo>
                  <m:mn>2</m:mn>
                </m:mrow>
                <m:mi>m</m:mi>
              </m:munderover>
              <m:msub>
                <m:mi>α</m:mi>
                <m:mi>i</m:mi>
              </m:msub>
              <m:msup>
                <m:mi>y</m:mi>
                <m:mrow>
                  <m:mo>(</m:mo>
                  <m:mi>i</m:mi>
                  <m:mo>)</m:mo>
                </m:mrow>
              </m:msup>
              <m:mo>.</m:mo>
            </m:mrow>
          </m:math>
        </equation>
        <para id="id78591">Or, by multiplying both sides by <m:math overflow="scroll"><m:msup><m:mi>y</m:mi><m:mrow><m:mo>(</m:mo><m:mn>1</m:mn><m:mo>)</m:mo></m:mrow></m:msup></m:math>, we equivalently have</para>
        <equation id="id78617">
          <m:math overflow="scroll" mode="display">
            <m:mrow>
              <m:msub>
                <m:mi>α</m:mi>
                <m:mn>1</m:mn>
              </m:msub>
              <m:mo>=</m:mo>
              <m:mo>-</m:mo>
              <m:msup>
                <m:mi>y</m:mi>
                <m:mrow>
                  <m:mo>(</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>)</m:mo>
                </m:mrow>
              </m:msup>
              <m:munderover>
                <m:mo>∑</m:mo>
                <m:mrow>
                  <m:mi>i</m:mi>
                  <m:mo>=</m:mo>
                  <m:mn>2</m:mn>
                </m:mrow>
                <m:mi>m</m:mi>
              </m:munderover>
              <m:msub>
                <m:mi>α</m:mi>
                <m:mi>i</m:mi>
              </m:msub>
              <m:msup>
                <m:mi>y</m:mi>
                <m:mrow>
                  <m:mo>(</m:mo>
                  <m:mi>i</m:mi>
                  <m:mo>)</m:mo>
                </m:mrow>
              </m:msup>
              <m:mo>.</m:mo>
            </m:mrow>
          </m:math>
        </equation>
        <para id="id78690">(This step used the fact that <m:math overflow="scroll"><m:mrow><m:msup><m:mi>y</m:mi><m:mrow><m:mo>(</m:mo><m:mn>1</m:mn><m:mo>)</m:mo></m:mrow></m:msup><m:mo>∈</m:mo><m:mrow><m:mo>{</m:mo><m:mo>-</m:mo><m:mn>1</m:mn><m:mo>,</m:mo><m:mn>1</m:mn><m:mo>}</m:mo></m:mrow></m:mrow></m:math>, and hence <m:math overflow="scroll"><m:mrow><m:msup><m:mrow><m:mo>(</m:mo><m:msup><m:mi>y</m:mi><m:mrow><m:mo>(</m:mo><m:mn>1</m:mn><m:mo>)</m:mo></m:mrow></m:msup><m:mo>)</m:mo></m:mrow><m:mn>2</m:mn></m:msup><m:mo>=</m:mo><m:mn>1</m:mn></m:mrow></m:math>.) Hence,
<m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mn>1</m:mn></m:msub></m:math> is exactly determined by the other <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mi>i</m:mi></m:msub></m:math>'s, and if we were to
hold <m:math overflow="scroll"><m:mrow><m:msub><m:mi>α</m:mi><m:mn>2</m:mn></m:msub><m:mo>,</m:mo><m:mo>...</m:mo><m:mo>,</m:mo><m:msub><m:mi>α</m:mi><m:mi>m</m:mi></m:msub></m:mrow></m:math> fixed, then we can't make any change to <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mn>1</m:mn></m:msub></m:math> without
violating the constraint (last equation in <link target-id="uid26"/>) in the optimization problem.</para><para id="id78846">Thus, if we want to update some subject of the <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mi>i</m:mi></m:msub></m:math>'s, we must update at least
two of them simultaneously in order to keep satisfying the constraints. This motivates
the SMO algorithm, which simply does the following:</para>
        <list id="id78865" display="block" list-type="bulleted">
          <item id="uid27"><label/>Repeat till convergence <m:math overflow="scroll"><m:mo>{</m:mo></m:math><list id="id78890" display="block" list-type="enumerated"><item id="uid28">Select some pair <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mi>i</m:mi></m:msub></m:math> and <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mi>j</m:mi></m:msub></m:math> to update next (using a heuristic that tries
to pick the two that will allow us to make the biggest progress towards the global maximum).
</item><item id="uid29">Reoptimize <m:math overflow="scroll"><m:mrow><m:mi>W</m:mi><m:mo>(</m:mo><m:mi>α</m:mi><m:mo>)</m:mo></m:mrow></m:math> with respect to <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mi>i</m:mi></m:msub></m:math> and <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mi>j</m:mi></m:msub></m:math>, while holding all
the other <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mi>k</m:mi></m:msub></m:math>'s (<m:math overflow="scroll"><m:mrow><m:mi>k</m:mi><m:mo>≠</m:mo><m:mi>i</m:mi><m:mo>,</m:mo><m:mi>j</m:mi></m:mrow></m:math>) fixed.
</item></list></item>
          <item id="uid30">
            <label/>
            <m:math overflow="scroll">
              <m:mo>}</m:mo>
            </m:math>
          </item>
        </list>
        <para id="id79047">To test for convergence of this algorithm, we can check whether the KKT conditions
(<link target-id="uid16"/>) are satisfied to within some <m:math overflow="scroll"><m:mrow><m:mi mathvariant="italic">t</m:mi><m:mi>o</m:mi><m:mi>l</m:mi></m:mrow></m:math>.
Here, <m:math overflow="scroll"><m:mrow><m:mi mathvariant="italic">t</m:mi><m:mi>o</m:mi><m:mi>l</m:mi></m:mrow></m:math> is the convergence tolerance parameter, and is typically set to
around 0.01 to 0.001. (See the paper and pseudocode for details.)</para><para id="id79093">The key reason that SMO is an efficient algorithm is that the update
to <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mi>i</m:mi></m:msub></m:math>, <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mi>j</m:mi></m:msub></m:math> can be computed very efficiently.
Let's now briefly sketch the main ideas for deriving the efficient update.</para>
        <para id="id79126">Let's say we currently have some setting of the <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mi>i</m:mi></m:msub></m:math>'s that satisfy the
constraints in <link target-id="uid26"/>, and suppose we've
decided to hold <m:math overflow="scroll"><m:mrow><m:msub><m:mi>α</m:mi><m:mn>3</m:mn></m:msub><m:mo>,</m:mo><m:mo>...</m:mo><m:mo>,</m:mo><m:msub><m:mi>α</m:mi><m:mi>m</m:mi></m:msub></m:mrow></m:math> fixed, and want to reoptimize
<m:math overflow="scroll"><m:mrow><m:mi>W</m:mi><m:mo>(</m:mo><m:msub><m:mi>α</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:msub><m:mi>α</m:mi><m:mn>2</m:mn></m:msub><m:mo>,</m:mo><m:mo>...</m:mo><m:mo>,</m:mo><m:msub><m:mi>α</m:mi><m:mi>m</m:mi></m:msub><m:mo>)</m:mo></m:mrow></m:math> with respect to <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mn>1</m:mn></m:msub></m:math> and <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mn>2</m:mn></m:msub></m:math> (subject
to the constraints). From the final equation in <link target-id="uid26"/>, we require that</para><equation id="id79259">
          <m:math overflow="scroll" mode="display">
            <m:mrow>
              <m:msub>
                <m:mi>α</m:mi>
                <m:mn>1</m:mn>
              </m:msub>
              <m:msup>
                <m:mi>y</m:mi>
                <m:mrow>
                  <m:mo>(</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>)</m:mo>
                </m:mrow>
              </m:msup>
              <m:mo>+</m:mo>
              <m:msub>
                <m:mi>α</m:mi>
                <m:mn>2</m:mn>
              </m:msub>
              <m:msup>
                <m:mi>y</m:mi>
                <m:mrow>
                  <m:mo>(</m:mo>
                  <m:mn>2</m:mn>
                  <m:mo>)</m:mo>
                </m:mrow>
              </m:msup>
              <m:mo>=</m:mo>
              <m:mo>-</m:mo>
              <m:munderover>
                <m:mo>∑</m:mo>
                <m:mrow>
                  <m:mi>i</m:mi>
                  <m:mo>=</m:mo>
                  <m:mn>3</m:mn>
                </m:mrow>
                <m:mi>m</m:mi>
              </m:munderover>
              <m:msub>
                <m:mi>α</m:mi>
                <m:mi>i</m:mi>
              </m:msub>
              <m:msup>
                <m:mi>y</m:mi>
                <m:mrow>
                  <m:mo>(</m:mo>
                  <m:mi>i</m:mi>
                  <m:mo>)</m:mo>
                </m:mrow>
              </m:msup>
              <m:mo>.</m:mo>
            </m:mrow>
          </m:math>
        </equation>
        <para id="id79354">Since the right hand side is fixed (as we've fixed <m:math overflow="scroll"><m:mrow><m:msub><m:mi>α</m:mi><m:mn>3</m:mn></m:msub><m:mo>,</m:mo><m:mo>...</m:mo><m:msub><m:mi>α</m:mi><m:mi>m</m:mi></m:msub></m:mrow></m:math>), we
can just let it be denoted by some constant <m:math overflow="scroll"><m:mi>ζ</m:mi></m:math>:</para>
        <equation id="uid31">
          <m:math overflow="scroll" mode="display">
            <m:mrow>
              <m:msub>
                <m:mi>α</m:mi>
                <m:mn>1</m:mn>
              </m:msub>
              <m:msup>
                <m:mi>y</m:mi>
                <m:mrow>
                  <m:mo>(</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>)</m:mo>
                </m:mrow>
              </m:msup>
              <m:mo>+</m:mo>
              <m:msub>
                <m:mi>α</m:mi>
                <m:mn>2</m:mn>
              </m:msub>
              <m:msup>
                <m:mi>y</m:mi>
                <m:mrow>
                  <m:mo>(</m:mo>
                  <m:mn>2</m:mn>
                  <m:mo>)</m:mo>
                </m:mrow>
              </m:msup>
              <m:mo>=</m:mo>
              <m:mi>ζ</m:mi>
              <m:mo>.</m:mo>
            </m:mrow>
          </m:math>
        </equation>
        <para id="id79461">We can thus picture the constraints on <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mn>1</m:mn></m:msub></m:math> and <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mn>2</m:mn></m:msub></m:math> as follows:</para>
        <figure id="uid32"><media id="uid32_media" alt="a graph with the above equation">
            <image mime-type="image/png" src="../../media/alphaConstraints.png" id="uid32_onlineimage" width="381"><!-- NOTE: attribute width changes image size online (pixels). original width is 381. --></image>
            <image mime-type="application/postscript" for="pdf" print-width="3.5in" src="../../media/alphaConstraints.eps" id="uid32_printimage"/>
          </media>
        </figure><para id="id79504">From the constraints <link target-id="uid26"/>, we know that <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mn>1</m:mn></m:msub></m:math> and <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mn>2</m:mn></m:msub></m:math> must
lie within the box <m:math overflow="scroll"><m:mrow><m:mo>[</m:mo><m:mn>0</m:mn><m:mo>,</m:mo><m:mi>C</m:mi><m:mo>]</m:mo><m:mo>×</m:mo><m:mo>[</m:mo><m:mn>0</m:mn><m:mo>,</m:mo><m:mi>C</m:mi><m:mo>]</m:mo></m:mrow></m:math> shown. Also plotted is the line
<m:math overflow="scroll"><m:mrow><m:msub><m:mi>α</m:mi><m:mn>1</m:mn></m:msub><m:msup><m:mi>y</m:mi><m:mrow><m:mo>(</m:mo><m:mn>1</m:mn><m:mo>)</m:mo></m:mrow></m:msup><m:mo>+</m:mo><m:msub><m:mi>α</m:mi><m:mn>2</m:mn></m:msub><m:msup><m:mi>y</m:mi><m:mrow><m:mo>(</m:mo><m:mn>2</m:mn><m:mo>)</m:mo></m:mrow></m:msup><m:mo>=</m:mo><m:mi>ζ</m:mi></m:mrow></m:math>, on which we know
<m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mn>1</m:mn></m:msub></m:math> and <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mn>2</m:mn></m:msub></m:math> must lie. Note also that, from these constraints,
we know <m:math overflow="scroll"><m:mrow><m:mi>L</m:mi><m:mo>≤</m:mo><m:msub><m:mi>α</m:mi><m:mn>2</m:mn></m:msub><m:mo>≤</m:mo><m:mi>H</m:mi></m:mrow></m:math>; otherwise, <m:math overflow="scroll"><m:mrow><m:mo>(</m:mo><m:msub><m:mi>α</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:msub><m:mi>α</m:mi><m:mn>2</m:mn></m:msub><m:mo>)</m:mo></m:mrow></m:math> can't simultaneously
satisfy both the box and the straight line constraint. In this example, <m:math overflow="scroll"><m:mrow><m:mi>L</m:mi><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow></m:math>. But depending on
what the line <m:math overflow="scroll"><m:mrow><m:msub><m:mi>α</m:mi><m:mn>1</m:mn></m:msub><m:msup><m:mi>y</m:mi><m:mrow><m:mo>(</m:mo><m:mn>1</m:mn><m:mo>)</m:mo></m:mrow></m:msup><m:mo>+</m:mo><m:msub><m:mi>α</m:mi><m:mn>2</m:mn></m:msub><m:msup><m:mi>y</m:mi><m:mrow><m:mo>(</m:mo><m:mn>2</m:mn><m:mo>)</m:mo></m:mrow></m:msup><m:mo>=</m:mo><m:mi>ζ</m:mi></m:mrow></m:math> looks like,
this won't always necessarily be the case; but more generally, there will be
some lower-bound <m:math overflow="scroll"><m:mi>L</m:mi></m:math> and some upper-bound <m:math overflow="scroll"><m:mi>H</m:mi></m:math> on the permissable
values for <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mn>2</m:mn></m:msub></m:math> that will ensure that <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mn>1</m:mn></m:msub></m:math>, <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mn>2</m:mn></m:msub></m:math> lie
within the box <m:math overflow="scroll"><m:mrow><m:mo>[</m:mo><m:mn>0</m:mn><m:mo>,</m:mo><m:mi>C</m:mi><m:mo>]</m:mo><m:mo>×</m:mo><m:mo>[</m:mo><m:mn>0</m:mn><m:mo>,</m:mo><m:mi>C</m:mi><m:mo>]</m:mo></m:mrow></m:math>.</para>
        <para id="id79876">Using Equation <link target-id="uid31"/>, we can also write <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mn>1</m:mn></m:msub></m:math> as a
function of <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mn>2</m:mn></m:msub></m:math>:</para>
        <equation id="id79913">
          <m:math overflow="scroll" mode="display">
            <m:mrow>
              <m:msub>
                <m:mi>α</m:mi>
                <m:mn>1</m:mn>
              </m:msub>
              <m:mo>=</m:mo>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mi>ζ</m:mi>
                <m:mo>-</m:mo>
                <m:msub>
                  <m:mi>α</m:mi>
                  <m:mn>2</m:mn>
                </m:msub>
                <m:msup>
                  <m:mi>y</m:mi>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mn>2</m:mn>
                    <m:mo>)</m:mo>
                  </m:mrow>
                </m:msup>
                <m:mo>)</m:mo>
              </m:mrow>
              <m:msup>
                <m:mi>y</m:mi>
                <m:mrow>
                  <m:mo>(</m:mo>
                  <m:mn>1</m:mn>
                  <m:mo>)</m:mo>
                </m:mrow>
              </m:msup>
              <m:mo>.</m:mo>
            </m:mrow>
          </m:math>
        </equation>
        <para id="id79977">(Check this derivation yourself; we again used the fact that
<m:math overflow="scroll"><m:mrow><m:msup><m:mi>y</m:mi><m:mrow><m:mo>(</m:mo><m:mn>1</m:mn><m:mo>)</m:mo></m:mrow></m:msup><m:mo>∈</m:mo><m:mrow><m:mo>{</m:mo><m:mo>-</m:mo><m:mn>1</m:mn><m:mo>,</m:mo><m:mn>1</m:mn><m:mo>}</m:mo></m:mrow></m:mrow></m:math> so that <m:math overflow="scroll"><m:mrow><m:msup><m:mrow><m:mo>(</m:mo><m:msup><m:mi>y</m:mi><m:mrow><m:mo>(</m:mo><m:mn>1</m:mn><m:mo>)</m:mo></m:mrow></m:msup><m:mo>)</m:mo></m:mrow><m:mn>2</m:mn></m:msup><m:mo>=</m:mo><m:mn>1</m:mn></m:mrow></m:math>.) Hence, the objective <m:math overflow="scroll"><m:mrow><m:mi>W</m:mi><m:mo>(</m:mo><m:mi>α</m:mi><m:mo>)</m:mo></m:mrow></m:math> can
be written</para>
        <equation id="id80072">
          <m:math overflow="scroll" mode="display">
            <m:mrow>
              <m:mi>W</m:mi>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:msub>
                  <m:mi>α</m:mi>
                  <m:mn>1</m:mn>
                </m:msub>
                <m:mo>,</m:mo>
                <m:msub>
                  <m:mi>α</m:mi>
                  <m:mn>2</m:mn>
                </m:msub>
                <m:mo>,</m:mo>
                <m:mo>...</m:mo>
                <m:mo>,</m:mo>
                <m:msub>
                  <m:mi>α</m:mi>
                  <m:mi>m</m:mi>
                </m:msub>
                <m:mo>)</m:mo>
              </m:mrow>
              <m:mo>=</m:mo>
              <m:mi>W</m:mi>
              <m:mrow>
                <m:mo>(</m:mo>
                <m:mrow>
                  <m:mo>(</m:mo>
                  <m:mi>ζ</m:mi>
                  <m:mo>-</m:mo>
                  <m:msub>
                    <m:mi>α</m:mi>
                    <m:mn>2</m:mn>
                  </m:msub>
                  <m:msup>
                    <m:mi>y</m:mi>
                    <m:mrow>
                      <m:mo>(</m:mo>
                      <m:mn>2</m:mn>
                      <m:mo>)</m:mo>
                    </m:mrow>
                  </m:msup>
                  <m:mo>)</m:mo>
                </m:mrow>
                <m:msup>
                  <m:mi>y</m:mi>
                  <m:mrow>
                    <m:mo>(</m:mo>
                    <m:mn>1</m:mn>
                    <m:mo>)</m:mo>
                  </m:mrow>
                </m:msup>
                <m:mo>,</m:mo>
                <m:msub>
                  <m:mi>α</m:mi>
                  <m:mn>2</m:mn>
                </m:msub>
                <m:mo>,</m:mo>
                <m:mo>...</m:mo>
                <m:mo>,</m:mo>
                <m:msub>
                  <m:mi>α</m:mi>
                  <m:mi>m</m:mi>
                </m:msub>
                <m:mo>)</m:mo>
              </m:mrow>
              <m:mo>.</m:mo>
            </m:mrow>
          </m:math>
        </equation>
        <para id="id80200">Treating <m:math overflow="scroll"><m:mrow><m:msub><m:mi>α</m:mi><m:mn>3</m:mn></m:msub><m:mo>,</m:mo><m:mo>...</m:mo><m:mo>,</m:mo><m:msub><m:mi>α</m:mi><m:mi>m</m:mi></m:msub></m:mrow></m:math> as constants, you should be able to verify that
this is just some quadratic function in <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mn>2</m:mn></m:msub></m:math>. I.e., this can also be expressed
in the form <m:math overflow="scroll"><m:mrow><m:mi>a</m:mi><m:msubsup><m:mi>α</m:mi><m:mn>2</m:mn><m:mn>2</m:mn></m:msubsup><m:mo>+</m:mo><m:mi>b</m:mi><m:msub><m:mi>α</m:mi><m:mn>2</m:mn></m:msub><m:mo>+</m:mo><m:mi>c</m:mi></m:mrow></m:math> for some appropriate <m:math overflow="scroll"><m:mi>a</m:mi></m:math>, <m:math overflow="scroll"><m:mi>b</m:mi></m:math>, and <m:math overflow="scroll"><m:mi>c</m:mi></m:math>.
If we ignore the “box” constraints <link target-id="uid26"/> (or, equivalently, that
<m:math overflow="scroll"><m:mrow><m:mi>L</m:mi><m:mo>≤</m:mo><m:msub><m:mi>α</m:mi><m:mn>2</m:mn></m:msub><m:mo>≤</m:mo><m:mi>H</m:mi></m:mrow></m:math>), then we can easily maximize this quadratic function
by setting its derivative to zero and solving. We'll let <m:math overflow="scroll"><m:msubsup><m:mi>α</m:mi><m:mn>2</m:mn><m:mrow><m:mi mathvariant="italic">n</m:mi><m:mi>e</m:mi><m:mi>w</m:mi><m:mo>,</m:mo><m:mi>u</m:mi><m:mi>n</m:mi><m:mi>c</m:mi><m:mi>l</m:mi><m:mi>i</m:mi><m:mi>p</m:mi><m:mi>p</m:mi><m:mi>e</m:mi><m:mi>d</m:mi></m:mrow></m:msubsup></m:math>
denote the resulting value of <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mn>2</m:mn></m:msub></m:math>. You should also be able to convince yourself
that if we had instead wanted to maximize <m:math overflow="scroll"><m:mi>W</m:mi></m:math> with respect to <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mn>2</m:mn></m:msub></m:math> but subject to
the box constraint, then we can find the resulting value optimal simply by taking
<m:math overflow="scroll"><m:msubsup><m:mi>α</m:mi><m:mn>2</m:mn><m:mrow><m:mi mathvariant="italic">n</m:mi><m:mi>e</m:mi><m:mi>w</m:mi><m:mo>,</m:mo><m:mi>u</m:mi><m:mi>n</m:mi><m:mi>c</m:mi><m:mi>l</m:mi><m:mi>i</m:mi><m:mi>p</m:mi><m:mi>p</m:mi><m:mi>e</m:mi><m:mi>d</m:mi></m:mrow></m:msubsup></m:math> and “clipping” it to lie in the <m:math overflow="scroll"><m:mrow><m:mo>[</m:mo><m:mi>L</m:mi><m:mo>,</m:mo><m:mi>H</m:mi><m:mo>]</m:mo></m:mrow></m:math> interval,
to get
</para>
        <equation id="id80610"><m:math overflow="scroll" mode="display">
            <m:mtable displaystyle="true">
              <m:mtr>
                <m:mtd columnalign="right">
                  <m:msubsup>
                    <m:mi>α</m:mi>
                    <m:mn>2</m:mn>
                    <m:mrow>
                      <m:mi mathvariant="italic">n</m:mi>
                      <m:mi>e</m:mi>
                      <m:mi>w</m:mi>
                    </m:mrow>
                  </m:msubsup>
                </m:mtd>
                <m:mtd>
                  <m:mo>=</m:mo>
                </m:mtd>
                <m:mtd columnalign="left">
<m:mfenced separators="" open="{" close="">

<m:mtable>
  <m:mtr>
    <m:mtd><m:mi>H</m:mi>
    </m:mtd>
    <m:mtd>
<m:mtext>if</m:mtext><m:mspace width=".5em"/>
<m:msubsup><m:mi>α</m:mi><m:mn>2</m:mn><m:mrow><m:mtext mathvariant="italic">new, unclipped</m:mtext></m:mrow></m:msubsup>
<m:mo>&gt;</m:mo><m:mi>H</m:mi>
    </m:mtd>
  </m:mtr>
  <m:mtr>
    <m:mtd>
<m:msubsup><m:mi>α</m:mi><m:mn>2</m:mn><m:mrow><m:mtext mathvariant="italic">new, unclipped</m:mtext></m:mrow></m:msubsup>
    </m:mtd>
    <m:mtd>
<m:mi>L</m:mi><m:mo>≤</m:mo>
<m:mtext>if</m:mtext><m:mspace width=".5em"/>
<m:msubsup><m:mi>α</m:mi><m:mn>2</m:mn><m:mrow><m:mtext mathvariant="italic">new, unclipped</m:mtext></m:mrow></m:msubsup>
<m:mo>≤</m:mo><m:mi>H</m:mi>
    </m:mtd>
  </m:mtr>
  <m:mtr>
    <m:mtd><m:mi>L</m:mi>
    </m:mtd>
    <m:mtd>
<m:mtext>if</m:mtext><m:mspace width=".5em"/>
<m:msubsup><m:mi>α</m:mi><m:mn>2</m:mn><m:mrow><m:mtext mathvariant="italic">new, unclipped</m:mtext></m:mrow></m:msubsup>
<m:mo>&lt;</m:mo><m:mi>L</m:mi>
    </m:mtd>
  </m:mtr>
</m:mtable>

</m:mfenced>
                </m:mtd>
              </m:mtr>
            </m:mtable>
          </m:math>
        </equation><para id="id80660">Finally, having found the <m:math overflow="scroll"><m:msubsup><m:mi>α</m:mi><m:mn>2</m:mn><m:mrow><m:mi mathvariant="italic">n</m:mi><m:mi>e</m:mi><m:mi>w</m:mi></m:mrow></m:msubsup></m:math>, we can use Equation <link target-id="uid31"/>
to go back and find the optimal value of <m:math overflow="scroll"><m:msubsup><m:mi>α</m:mi><m:mn>1</m:mn><m:mrow><m:mi mathvariant="italic">n</m:mi><m:mi>e</m:mi><m:mi>w</m:mi></m:mrow></m:msubsup></m:math>.</para>
        <para id="id80721">There're a couple more details that are quite easy but that we'll leave you
to read about yourself in Platt's paper: One is the choice of the heuristics used
to select the next <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mi>i</m:mi></m:msub></m:math>, <m:math overflow="scroll"><m:msub><m:mi>α</m:mi><m:mi>j</m:mi></m:msub></m:math> to update; the other is how to
update <m:math overflow="scroll"><m:mi>b</m:mi></m:math> as the SMO algorithm is run.</para>
      </section>
    </section>
  </content>
</document>